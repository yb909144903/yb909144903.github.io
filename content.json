{"meta":{"title":"Timbok's Blog","subtitle":"B.Y'S BLOG","description":"看到这段话说明你也是个IT工作者，这里有很多不错的技术博，希望和大家成为朋友，互相进步。","author":"Timbok","url":"https://yb909144903.github.io"},"pages":[{"title":"文章分类","date":"2018-11-29T08:08:09.000Z","updated":"2018-12-21T03:10:52.480Z","comments":false,"path":"categories/index.html","permalink":"https://yb909144903.github.io/categories/index.html","excerpt":"","text":""},{"title":"个人简历","date":"2018-11-29T11:24:59.000Z","updated":"2018-12-02T08:23:17.810Z","comments":true,"path":"introduce/index.html","permalink":"https://yb909144903.github.io/introduce/index.html","excerpt":"","text":"Timbok(yb909144903@gmail.com)个人信息 学历：本科 专业：软件工程 职业：web前端小白 发量：茂盛 技术博客：https://timbok.top 地点： 上海 项目经历 ████████████████████ ████████████████████ ████████████████████ ████████████████████ 技能列表 熟悉vueJS、React等主流MVC、MVVM框架； 掌握localStorage、sessionStorage等前端存储方案，记录用户操作习惯或常用数据，从而降低HTTP请求，提升用户体验； 熟练使用SVN、git版本控制工具，进行代码管理，实现敏捷开发； 熟练使用Bootstarp框架，通过栅格系统快速布局响应式页面以适应 不同设备； 熟练使用Ajax，实现异步页面无刷新抽取数据，同步校验数据； 熟练使用HTML、CSS、JavaScript等前端技术，完成网页静态布局， 开发兼容主流浏览器的页面，以及实现页面的交互，提升用户体验； 了解node.js，利用其搭建简单的服务器。 个人爱好 吃饭、睡觉、打豆豆 打LOL"},{"title":"Daily Sharing","date":"2019-01-30T09:30:07.511Z","updated":"2019-01-30T09:30:07.511Z","comments":true,"path":"drip/index.html","permalink":"https://yb909144903.github.io/drip/index.html","excerpt":"","text":"好文推荐 lodash的debounce,bind和es7的@装饰器 this、apply、call、bind 手把手教你撸一个简易的 webpack JavaScript开发者应懂的33个概念"}],"posts":[{"title":"TYPESCRIPT指南（译文）","slug":"TypeScript","date":"2019-01-30T02:39:41.000Z","updated":"2019-01-30T02:43:15.145Z","comments":true,"path":"2019/01/30/TypeScript/","link":"","permalink":"https://yb909144903.github.io/2019/01/30/TypeScript/","excerpt":"","text":"前言 原文地址：https://flaviocopes.com/typescript/ 原文作者：Flavio 译者：Timbok 翻译工具：Google Translate 正文什么？都2019了，你还不会TypeScirpt？别担心，我也不会，前几天看到一篇写的很好的入门文章，翻译一下，一起学习。 TypeScript是2018年发展最快的技术之一。它无处不在，每个人都在谈论它。本文将指导您了解其关键概念 过去几年中，很少有技术能有TypeScript这么大的影响。让我添加一些证据，支持TypeScript。 在“The State of JavaScript 2018”调查中，近50％的受访者表示他们使用TypeScript，并会再次使用它。超过30％的人表示他们想学习它。对此感兴趣的人中有很大一部分。 TypeScript是由微软创建的，它对于创建编程语言并不陌生，其创建者之一是Anders Hejlsberg，一位以Turbo Pascal（❤️）和Delphi而闻名的丹麦软件工程师。我把心思放在Turbo Pascal上，因为Pascal是我的第一个编程语言，我们在学校使用了Turbo Pascal。 它是一种开源语言，在https://github.com/Microsoft/TypeScript上公开开发。 Angular是使用TypeScript的，据说Vue.js使用TypeScript制作3.0版本。Node.js的创建者Ryan Dahl也说了很多关于它的事情。 我认为这些东西有助于你清晰认识TypeScript。这不仅仅是一种随机的JavaScript风格，将在下个月消亡，它绝对会留下来。事实上，这意味着您可能需要在未来的项目或下一个工作中使用它。也许它会帮助你找到一份工作，所以让我们深入研究它。 编写并编译您的第一个TYPESCRIPT文件TypeScript开始很容易。如果您曾经写过一行JavaScript，那么您已经编写了TypeScript代码！ 我所做的这个奇怪的陈述是TypeScript成功的原因之一：它是JavaScript的严格超集。 这有点像SCSS的CSS。 特别是，它是ECMAScript 2015（也称为ES6）的超集。这意味着任何有效的JavaScript也是有效的TypeScript。 TypeScript的许多功能都等同于JavaScript。例如变量，模块系统，迭代器等。 所以，没有必要编写绝对的第一个TypeScript文件，因为你已经在你不知道的情况下写过，让我们通过显式制作一个TypeScript文件来制作一个“hello world！”，并将其编译成JavaScript。 运行npm install -g typescript以全局安装可使用tsc命令使用的TypeScript编译器。 创建一个新文件夹，然后创建一个app.ts文件。.ts是TypeScript文件扩展名。 写下第一个程序：12345const greet = () =&gt; &#123; console.log('Hello world!')&#125;greet() 这只是普通的JavaScript，但存储在一个.ts文件中。 现在使用编译程序tsc app.ts。结果将是一个新的JavaScript文件：app.js，包含以下内容：1234var greet = function () &#123; console.log('Hello world!');&#125;;greet(); TypeScript代码已编译为JavaScript。JavaScript代码稍有改动，例如你可以注意到它添加了分号，var用来代替const和使用常规函数而不是箭头函数。 它看起来像旧的 JavaScript，对吗？这是因为TypeScript默认编译为ES5，因为这是几乎可以保证在所有现代浏览器中都支持的ECMAScript版本。您可以将编译目标更改为其他版本，例如编译为ES2018：tsc app.ts --target ES2018： 1234const greet = () =&gt; &#123; console.log('Hello world!');&#125;;greet(); 看，这里几乎没有改变我们的原始.ts文件，除了额外的分号。 有一个非常方便的网站，可让您在https://www.typescriptlang.org/play/上使用TypeScript到JavaScript编辑。 类型到目前为止，我们编译了一个.ts文件，但我们只编译了纯JavaScript。 您看到了TypeScript的第一个功能：您可以使用现代JavaScript并将其编译为ES5（或更高版本），这是Babel所做的。我们还没有使用任何TypeScript功能。 TypeScript提供的最重要的功能是类型系统：静态类型，接口，类型推断，枚举，混合类型，泛型，联合/交集类型，访问修饰符，空检查。 如果你曾经使用过类型语言，比如Go或C，你已经知道它是如何工作的。如果没有，并且您只使用Python或Ruby这样的动态语言进行编程，这对您来说是全新的，但不要担心。 例如，类型系统允许您向变量，函数参数和函数返回类型添加类型，从而为程序提供更严格的结构。我们编译的JavaScript代码没有类型，它们在编译阶段会丢失。 以下是在TypeScript中定义字符串变量的方法：1const greeting : string = \"hello!\" 类型推断让我们避免在明显的情况下编写类型：1const greeting = \"hello!\" 类型由TS确定。 这是函数接受特定类型的参数的方式：123const multiply = (a: number, b: number) =&gt; &#123; return a * b&#125; 如果传递一个字符串给multiply()，编译器会给你一个错误。 以下是函数声明其返回值的方式：123const multiply = (a: number, b: number): number =&gt; &#123; return a * b&#125; 有效类型是 number string boolean enum void null undefined any never Array tuple any 是一种全能类型，如其名称所示，可识别任何类型。 类ES2015 / ES6为JavaScript 添加了类，作为原型继承的简单语法糖。 无论喜欢与否，在引擎盖下，JavaScript仍然使用原型继承，具有其独特的功能和怪癖。 TypeScript类与JavaScript类略有不同。原因是TypeScript在JavaScript之前引入了类（它们是在ES2015 / ES6中引入的）。 就像在JavaScript中一样，您以这种方式声明类：123class Car &#123;&#125; 默认情况下，所有字段都是公开 您可以将字段设置为私有或受保护：12345class Car &#123; public color: string private name: string protected brand: string&#125; 就像在其他编程语言中发生的那样，私有字段只能在声明它们的类中访问。受保护的字段也只能通过派生类来访问。 您还可以声明静态字段，它们是类字段而不是对象字段：123class Car &#123; static numberOfWheels = 4&#125; 您可以使用构造函数初始化字段：123456class Car &#123; color: string constructor(theColor: string) &#123; this.color = theColor &#125;&#125; 这种简写语法使其更简单：123456789class Car &#123; constructor(public color: string) &#123;&#125; printColor() &#123; alert(this.color) &#125;&#125;(new Car('red')).printColor() 字段也可以是只读的：123class Car &#123; readonly color: string&#125; 在这种情况下，它的值只能在构造函数中设置。 类具有方法：123456789class Car &#123; color: string constructor(public color: string) &#123; this.color = color &#125; drive() &#123; console.log('You are driving the car') &#125;&#125; 与纯JavaScript一样，您可以使用new关键字从这些类创建对象：1const myCar = new Car('red') 并且您可以使用extend关键字扩展现有类：123class ElectricCar extends Car &#123; //...&#125; 您可以在构造函数和方法中调用super()来调用扩展类对应的方法 类可以定义为抽象，这意味着需要有一个扩展它的类，并实现其最终的抽象方法：123456789abstract class Car &#123; abstract drive()&#125;class SportsCar extends Car &#123; drive() &#123; console.log('You are driving a sports car') &#125;&#125; 访问器字段可以有getter和setter。例：1234567891011class Car &#123; private _color: string get color(): string &#123; return this._color &#125; set color(color: string) &#123; this._color = color &#125;&#125; 接口接口基于基本类型构建。您可以将接口用作类型，并且此接口可以包含其他类型定义：12345678910interface SetOfNumbers &#123; a: number; b: number;&#125;const multiply = (set: SetOfNumbers) =&gt; &#123; return set.a * set.b&#125;multiply(&#123; a:1, b: 2 &#125;) 接口也可以是类实现的接口：123456789101112131415interface Car &#123; name: 'string' new (brand: string) drive(): void&#125;class SportsCar implements Car &#123; public name construtor(public brand: string) &#123; //... &#125; drive() &#123; console.log('You are driving a sports car') &#125;&#125; 函数特点函数可以使用?来表明参数类型可选：123456789class Car &#123; drive(kilometers?: number) &#123; if (kilometers) &#123; console.log(`Drive the car for $&#123;kilometers&#125; kilometers`) &#125; else &#123; console.log(`Drive the car`) &#125; &#125;&#125; 参数也可以有默认值：12345class Car &#123; drive(kilometers = 10) &#123; console.log(`Drive the car for $&#123;kilometers&#125; kilometers`) &#125;&#125; 函数可以使用...接受不同数量的参数：1234567class Car &#123; drive(kilometers = 10, ...occupants: string[]) &#123; console.log(`Drive the car for $&#123;kilometers&#125; kilometers, with those people on it:`) occupants.map((person) =&gt; console.log(person)) &#125;&#125;(new Car()).drive(20, 'Flavio', 'Roger', 'Syd') 枚举枚举是定义命名常量的一种很好的方法，遗憾的是，它不受JavaScript支持，但是被其他语言推广。 TypeScript为我们提供了枚举：123456enum Order &#123; First, Second, Third, Fourth&#125; TS在内部为每个值分配唯一标识符，我们可以简单地引用Order.First，Order.Second依此类推。 您可以显式地为常量指定值：123456enum Order &#123; First = 0, Second = 1, Third = 2, Fourth = 3&#125; 或者也使用字符串：123456enum Order &#123; First = 'FIRST', Second = 'SECOND', Third = 'THIRD', Fourth = 'FOURTH'&#125; 泛型泛型是许多不同编程语言的一部分。简而言之，您可以创建一个使用不同类型的函数，接口或类，而无需预先指定类型。 但是在编译时，如果你开始使用一个类型的函数，然后你改变类型（例如从数字到字符串），编译器将抛出一个错误。 我们可以通过省略类型或使用any类型来实现这一点，但是使用泛型，所有工具都能够帮助我们 示例语法：1234function greet&lt;T&gt;(a : T) &#123; console.log(`Hi $&#123;a&#125;!`)&#125;greet('Flavio') 有趣的T符号标识通用类型。 可以使用以下extends关键字将类型限制为某个类或接口：12345interface Greetable &#123; name: string &#125;function greet&lt;T extends Greetable&gt;(a : T) &#123; alert(`Hi $&#123;a.name&#125;!`)&#125;greet(&#123; name: 'Flavio'&#125;) 总结这些都是TypeScript的基础知识。详细学习地址： 中文文档：https://github.com/zhongsp/TypeScript 英文文档：http://www.typescriptlang.org/docs/home.html 能力有限，水平一般，翻译不妥之处，还望指正。感谢。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yb909144903.github.io/tags/JavaScript/"}]},{"title":"每个JavaScript开发人员都应该知道的新ES2018功能（译文）","slug":"ES2018","date":"2019-01-13T07:40:24.000Z","updated":"2019-01-14T06:44:33.012Z","comments":true,"path":"2019/01/13/ES2018/","link":"","permalink":"https://yb909144903.github.io/2019/01/13/ES2018/","excerpt":"","text":"前言 原文地址：https://css-tricks.com/new-es2018-features-every-javascript-developer-should-know/ 原文作者：Faraz Kelhini 译者：Timbok 翻译工具：Google Translate 本文首发于我的个人网站: [Timbok.top]()--> 正文ECMAScript标准的第九版，官方称为ECMAScript 2018（或简称ES2018），于2018年6月发布。从ES2016开始，ECMAScript规范的新版本每年发布而不是每几年发布一次，并且添加的功能少于主要版本以前。该标准的最新版本通过添加四个新RegExp功能，rest/spread属性，asynchronous iteration，和Promise.prototype.finally。此外，ES2018从标记模板中删除了转义序列的语法限制。 这些新变化将在后面的小节中解释。 rest/spread属性ES2015最有趣的功能之一是点差运算符。该运算符使复制和合并数组变得更加简单。您可以使用运算符...，而不是调用concat()or slice()方法： 12345678910111213const arr1 = [10, 20, 30];// make a copy of arr1const copy = [...arr1];console.log(copy); // → [10, 20, 30]const arr2 = [40, 50];// merge arr2 with arr1const merge = [...arr1, ...arr2];console.log(merge); // → [10, 20, 30, 40, 50] 在必须作为函数的单独参数传入数组的情况下，扩展运算符也派上用场。例如： 12345const arr = [10, 20, 30]// equivalent to// console.log(Math.max(10, 20, 30));console.log(Math.max(...arr)); // → 30 ES2018通过向对象文字添加扩展属性来进一步扩展此语法。使用spread属性，您可以将对象的自身可枚举属性复制到新对象上。请考虑以下示例： 1234567891011const obj1 = &#123; a: 10, b: 20&#125;;const obj2 = &#123; ...obj1, c: 30&#125;;console.log(obj2); // → &#123;a: 10, b: 20, c: 30&#125; 在此代码中，...运算符用于检索属性obj1并将其分配给obj2。在ES2018之前，尝试这样做会引发错误。如果有多个具有相同名称的属性，则将使用最后一个属性： 1234567891011const obj1 = &#123; a: 10, b: 20&#125;;const obj2 = &#123; ...obj1, a: 30&#125;;console.log(obj2); // → &#123;a: 30, b: 20&#125; Spread属性还提供了一种合并两个或多个对象的新方法，可以将其用作方法的替代Object.assign()方法： 123456789const obj1 = &#123;a: 10&#125;;const obj2 = &#123;b: 20&#125;;const obj3 = &#123;c: 30&#125;;// ES2018console.log(&#123;...obj1, ...obj2, ...obj3&#125;); // → &#123;a: 10, b: 20, c: 30&#125;// ES2015console.log(Object.assign(&#123;&#125;, obj1, obj2, obj3)); // → &#123;a: 10, b: 20, c: 30&#125; 但请注意，spread属性并不总是产生相同的结果Object.assign()。请考虑以下代码： 1234567891011121314Object.defineProperty(Object.prototype, 'a', &#123; set(value) &#123; console.log('set called!'); &#125;&#125;);const obj = &#123;a: 10&#125;;console.log(&#123;...obj&#125;); // → &#123;a: 10&#125;console.log(Object.assign(&#123;&#125;, obj)); // → set called!// → &#123;&#125; 在此代码中，该Object.assign()方法执行继承的setter属性。相反，传播属性完全忽略了setter。 重要的是要记住，spread属性只复制可枚举的属性。在以下示例中，type属性不会显示在复制的对象中，因为其enumerable属性设置为false： 12345678910const car = &#123; color: 'blue'&#125;;Object.defineProperty(car, 'type', &#123; value: 'coupe', enumerable: false&#125;);console.log(&#123;...car&#125;); // → &#123;color: \"blue\"&#125; 即使它们是可枚举的，也会忽略继承的属性： 123456789101112131415161718const car = &#123; color: 'blue'&#125;;const car2 = Object.create(car, &#123; type: &#123; value: 'coupe', enumerable: true, &#125;&#125;);console.log(car2.color); // → blueconsole.log(car2.hasOwnProperty('color')); // → falseconsole.log(car2.type); // → coupeconsole.log(car2.hasOwnProperty('type')); // → trueconsole.log(&#123;...car2&#125;); // → &#123;type: \"coupe\"&#125; 在此代码中，car2继承color属性car。因为spread属性只复制对象的自己的属性，color所以不包含在返回值中。 请记住，spread属性只能生成对象的浅表副本。如果属性包含对象，则仅复制对象的引用： 12345const obj = &#123;x: &#123;y: 10&#125;&#125;;const copy1 = &#123;...obj&#125;; const copy2 = &#123;...obj&#125;; console.log(copy1.x === copy2.x); // → true 这里copy1和copy2的x是指在内存中的同一对象，所以全等运算返回true。 ES2015中添加的另一个有用功能是rest参数，它使JavaScript程序员可以使用它...来表示值作为数组。例如： 12345const arr = [10, 20, 30];const [x, ...rest] = arr;console.log(x); // → 10console.log(rest); // → [20, 30] 这里，arr的第一个值被分配给对应的x，而剩余的元素被分配给rest变量。这种称为阵列解构的模式变得如此受欢迎，以至于Ecma技术委员会决定为对象带来类似的功能： 12345678910const obj = &#123; a: 10, b: 20, c: 30&#125;;const &#123;a, ...rest&#125; = obj;console.log(a); // → 10console.log(rest); // → &#123;b: 20, c: 30&#125; 此代码使用解构赋值中的其余属性将剩余的自身可枚举属性复制到新对象中。请注意，rest属性必须始终出现在对象的末尾，否则会引发错误： 1234567const obj = &#123; a: 10, b: 20, c: 30&#125;;const &#123;...rest, a&#125; = obj; // → SyntaxError: Rest element must be last element 还要记住，在对象中使用多个rest会导致错误，除非它们是嵌套的： 123456789101112const obj = &#123; a: 10, b: &#123; x: 20, y: 30, z: 40 &#125;&#125;;const &#123;b: &#123;x, ...rest1&#125;, ...rest2&#125; = obj; // no errorconst &#123;...rest, ...rest2&#125; = obj; // → SyntaxError: Rest element must be last element Support for Rest/Spread Chrome Firefox Safari Edge 60 55 11.1 No Chrome Android Firefox Android iOS Safari Edge Mobile Samsung Internet Android Webview 60 55 11.3 No 8.2 60 Node.js 8.0.0（运行时需要加-harmony） 8.3.0（完全支持） Asynchronous Iteration(异步迭代)迭代数据集是编程的重要部分。此前ES2015，提供的JavaScript语句如for，for...in和while，和方法map()，filter()以及forEach()都用于此目的。为了使程序员能够一次一个地处理集合中的元素，ES2015引入了迭代器接口。 如果对象具有Symbol.iterator属性，则该对象是可迭代的。在ES2015中，字符串和集合对象（如Set，Map和Array）带有Symbol.iterator属性，因此可以迭代。以下代码给出了如何一次访问可迭代元素的示例： 1234567const arr = [10, 20, 30];const iterator = arr[Symbol.iterator](); console.log(iterator.next()); // → &#123;value: 10, done: false&#125;console.log(iterator.next()); // → &#123;value: 20, done: false&#125;console.log(iterator.next()); // → &#123;value: 30, done: false&#125;console.log(iterator.next()); // → &#123;value: undefined, done: true&#125; Symbol.iterator是一个众所周知的符号，指定一个返回迭代器的函数。与迭代器交互的主要方法是next()方法。此方法返回具有两个属性的对象：value和done。value属性为集合中下一个元素的值。done属性的值为true或false表示集合是否迭代完成。 默认情况下，普通对象不可迭代，但如果在其上定义Symbol.iterator属性，则它可以变为可迭代，如下例所示： 123456789101112131415161718192021222324const collection = &#123; a: 10, b: 20, c: 30, [Symbol.iterator]() &#123; const values = Object.keys(this); let i = 0; return &#123; next: () =&gt; &#123; return &#123; value: this[values[i++]], done: i &gt; values.length &#125; &#125; &#125;; &#125;&#125;;const iterator = collection[Symbol.iterator](); console.log(iterator.next()); // → &#123;value: 10, done: false&#125;console.log(iterator.next()); // → &#123;value: 20, done: false&#125;console.log(iterator.next()); // → &#123;value: 30, done: false&#125;console.log(iterator.next()); // → &#123;value: undefined, done: true&#125; 此对象是可迭代的，因为它定义了一个Symbol.iterator属性。迭代器使用该Object.keys()方法获取对象属性名称的数组，然后将其分配给values常量。它还定义了一个计数器变量i，并给它一个初始值0.当执行迭代器时，它返回一个包含next()方法的对象。每次调用next()方法时，它都返回一对{value, done}，value保持集合中的下一个元素并done保持一个布尔值，指示迭代器是否已达到集合的需要。 虽然这段代码完美无缺，但却不必要。使用生成器函数可以大大简化过程： 1234567891011121314151617const collection = &#123; a: 10, b: 20, c: 30, [Symbol.iterator]: function * () &#123; for (let key in this) &#123; yield this[key]; &#125; &#125;&#125;;const iterator = collection[Symbol.iterator](); console.log(iterator.next()); // → &#123;value: 10, done: false&#125;console.log(iterator.next()); // → &#123;value: 20, done: false&#125;console.log(iterator.next()); // → &#123;value: 30, done: false&#125;console.log(iterator.next()); // → &#123;value: undefined, done: true&#125; 在这个生成器中，for...in循环用于枚举集合并产生每个属性的值。结果与前一个示例完全相同，但它大大缩短了。 迭代器的缺点是它们不适合表示异步数据源。ES2018的补救解决方案是异步迭代器和异步迭代。异步迭代器与传统迭代器的不同之处在于，它不是以形式返回普通对象{value, done}，而是返回履行的承诺{value, done}。异步迭代定义了一个返回异步迭代器的Symbol.asyncIterator方法（而不是Symbol.iterator）。 一个例子让这个更清楚： 1234567891011121314151617181920212223242526272829303132333435const collection = &#123; a: 10, b: 20, c: 30, [Symbol.asyncIterator]() &#123; const values = Object.keys(this); let i = 0; return &#123; next: () =&gt; &#123; return Promise.resolve(&#123; value: this[values[i++]], done: i &gt; values.length &#125;); &#125; &#125;; &#125;&#125;;const iterator = collection[Symbol.asyncIterator](); console.log(iterator.next().then(result =&gt; &#123; console.log(result); // → &#123;value: 10, done: false&#125;&#125;));console.log(iterator.next().then(result =&gt; &#123; console.log(result); // → &#123;value: 20, done: false&#125; &#125;));console.log(iterator.next().then(result =&gt; &#123; console.log(result); // → &#123;value: 30, done: false&#125; &#125;));console.log(iterator.next().then(result =&gt; &#123; console.log(result); // → &#123;value: undefined, done: true&#125; &#125;)); 请注意，不可使用promises的迭代器来实现相同的结果。虽然普通的同步迭代器可以异步确定值，但它仍然需要同步确定done的状态。 同样，您可以使用生成器函数简化过程，如下所示： 12345678910111213141516171819202122232425262728const collection = &#123; a: 10, b: 20, c: 30, [Symbol.asyncIterator]: async function * () &#123; for (let key in this) &#123; yield this[key]; &#125; &#125;&#125;;const iterator = collection[Symbol.asyncIterator](); console.log(iterator.next().then(result =&gt; &#123; console.log(result); // → &#123;value: 10, done: false&#125;&#125;));console.log(iterator.next().then(result =&gt; &#123; console.log(result); // → &#123;value: 20, done: false&#125; &#125;));console.log(iterator.next().then(result =&gt; &#123; console.log(result); // → &#123;value: 30, done: false&#125; &#125;));console.log(iterator.next().then(result =&gt; &#123; console.log(result); // → &#123;value: undefined, done: true&#125; &#125;)); 通常，生成器函数返回带有next()方法的生成器对象。当调用next()时，它返回一个{value，done}，其value属性保存了yield值。异步生成器执行相同的操作，除了它返回一个履行{value，done}的promise。 迭代可迭代对象的一种简单方法是使用for...of语句，但是for...of不能与async iterables一起使用，因为value和done不是同步确定的。因此，ES2018提供了for...await...of。我们来看一个例子： 123456789101112131415161718192021const collection = &#123; a: 10, b: 20, c: 30, [Symbol.asyncIterator]: async function * () &#123; for (let key in this) &#123; yield this[key]; &#125; &#125;&#125;;(async function () &#123; for await (const x of collection) &#123; console.log(x); &#125;&#125;)();// logs:// → 10// → 20// → 30 在此代码中，for...await...of语句隐式调用Symbol.asyncIterator集合对象上的方法以获取异步迭代器。每次循环时，都会调用迭代器的next()方法，它返回一个promise。一旦解析了promise，就会将结果对象的value属性读取到x变量中。循环继续，直到返回的对象的done属性值为true。 请记住，该for...await...of语句仅在异步生成器和异步函数中有效。违反此规则会导致一个SyntaxError报错。 next()方法可能会返回拒绝的promise。要优雅地处理被拒绝的promise，您可以将for...await...of语句包装在语句中try...catch，如下所示： 1234567891011121314151617181920const collection = &#123; [Symbol.asyncIterator]() &#123; return &#123; next: () =&gt; &#123; return Promise.reject(new Error('Something went wrong.')) &#125; &#125;; &#125;&#125;;(async function() &#123; try &#123; for await (const value of collection) &#123;&#125; &#125; catch (error) &#123; console.log('Caught: ' + error.message); &#125;&#125;)();// logs:// → Caught: Something went wrong. Support for Asynchronous Iterators Chrome Firefox Safari Edge 63 57 12 No Chrome Android Firefox Android iOS Safari Edge Mobile Samsung Internet Android Webview 63 57 12 No 8.2 63 Node.js 8.0.0（运行时需要加-harmony） 8.3.0（完全支持） Promise.prototype.finallyES2018的另一个令人兴奋的补充是finally()方法。一些JavaScript库之前已经实现了类似的方法，这在许多情况下证明是有用的。这鼓励了Ecma技术委员会正式添加finally()到规范中。使用这个方法，程序员将能不管promise的结果如何，都能执行一个代码块。我们来看一个简单的例子： 12345678910fetch('https://www.google.com') .then((response) =&gt; &#123; console.log(response.status); &#125;) .catch((error) =&gt; &#123; console.log(error); &#125;) .finally(() =&gt; &#123; document.querySelector('#spinner').style.display = 'none'; &#125;); finally()无论操作是否成功，当您需要在操作完成后进行一些清理时，该方法会派上用场。在此代码中，该finally()方法只是在获取和处理数据后隐藏加载微调器。代码不是在then()和catch()方法中复制最终逻辑，而是在promise被fulfilled或rejected后注册要执行的函数。 你可以使用promise.then(func，func)而不是promise.finally(func)来实现相同的结果，但你必须在fulfillment处理程序和rejection处理程序中重复相同的代码，或者为它声明一个变量： 123456789101112fetch('https://www.google.com') .then((response) =&gt; &#123; console.log(response.status); &#125;) .catch((error) =&gt; &#123; console.log(error); &#125;) .then(final, final);function final() &#123; document.querySelector('#spinner').style.display = 'none';&#125; 和then()和catch()一样，finally()方法总是返回一个promise，因此可以链接更多的方法。通常，您希望使用finally()作为最后一个链，但在某些情况下，例如在发出HTTP请求时，最好链接另一个catch()以处理finally()中可能发生的错误。 Support for Promise.prototype.finally Chrome Firefox Safari Edge 63 58 11.1 18 Chrome Android Firefox Android iOS Safari Edge Mobile Samsung Internet Android Webview 63 58 11.1 No 8.2 63 Node.js 10.0.0（完全支持） 新的RegExp功能ES2018为该RegExp对象增加了四个新功能，进一步提高了JavaScript的字符串处理能力。这些功能如下： S（DOTALL）标志 Named Capture Groups(命名捕获组) Lookbehind Assertions(后向断言) Unicode Property Escapes(Unicode属性转义) S（DOTALL）标志点（.）是正则表达式模式中的特殊字符，它匹配除换行符之外的任何字符，例如换行符（\\n）或回车符（\\r）。匹配所有字符（包括换行符）的解决方法是使用具有两个相反短字的字符类，例如[\\d\\D]。此字符类告诉正则表达式引擎找到一个数字（\\d）或非数字（\\D）的字符。因此，它匹配任何字符： 1console.log(/one[\\d\\D]two/.test('one\\ntwo')); // → true ES2018引入了一种模式，其中点可用于实现相同的结果。可以使用s标志在每个正则表达式的基础上激活此模式： 12console.log(/one.two/.test('one\\ntwo')); // → falseconsole.log(/one.two/s.test('one\\ntwo')); // → true 使用标志来选择新行为的好处是向后兼容性。因此，使用点字符的现有正则表达式模式不受影响。 Named Capture Groups(命名捕获组)在一些正则表达式模式中，使用数字来引用捕获组可能会令人困惑。例如，使用/(\\d{4})-(\\d{2})-(\\d{2})/与日期匹配的正则表达式。由于美式英语中的日期符号与英式英语不同，因此很难知道哪个组指的是哪一天，哪个组指的是月份： 1234567const re = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;const match= re.exec('2019-01-10');console.log(match[0]); // → 2019-01-10console.log(match[1]); // → 2019console.log(match[2]); // → 01console.log(match[3]); // → 10 ES2018引入了使用(?&lt;name&gt;...)语法的命名捕获组。因此，匹配日期的模式可以用不那么模糊的方式编写： 1234567const re = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/;const match = re.exec('2019-01-10');console.log(match.groups); // → &#123;year: \"2019\", month: \"01\", day: \"10\"&#125;console.log(match.groups.year); // → 2019console.log(match.groups.month); // → 01console.log(match.groups.day); // → 10 您可以使用\\k&lt;name&gt;语法在模式中稍后调用命名的捕获组。例如，要在句子中查找连续的重复单词，您可以使用/\\b(?&lt;dup&gt;\\w+)\\s+\\k&lt;dup&gt;\\b/： 12345const re = /\\b(?&lt;dup&gt;\\w+)\\s+\\k&lt;dup&gt;\\b/;const match = re.exec('Get that that cat off the table!'); console.log(match.index); // → 4console.log(match[0]); // → that that 要将命名的捕获组插入到方法的替换字符串中replace()，您需要使用$&lt;name&gt;构造。例如： 1234567const str = 'red &amp; blue';console.log(str.replace(/(red) &amp; (blue)/, '$2 &amp; $1')); // → blue &amp; redconsole.log(str.replace(/(?&lt;red&gt;red) &amp; (?&lt;blue&gt;blue)/, '$&lt;blue&gt; &amp; $&lt;red&gt;')); // → blue &amp; red Lookbehind Assertions(后向断言)ES2018为JavaScript带来了后向性断言，这些断言已经在其他正则表达式实现中可用多年。以前，JavaScript只支持超前断言。后向断言用表示(?&lt;=...)，并使您能够匹配基于模式之前的子字符串的模式。例如，如果要在不捕获货币符号的情况下以美元，英镑或欧元匹配产品的价格，则可以使用/(?&lt;=\\$|£|€)\\d+(\\.\\d*)?/： 12345678910const re = /(?&lt;=\\$|£|€)\\d+(\\.\\d*)?/;console.log(re.exec('199')); // → nullconsole.log(re.exec('$199')); // → [\"199\", undefined, index: 1, input: \"$199\", groups: undefined]console.log(re.exec('€50')); // → [\"50\", undefined, index: 1, input: \"€50\", groups: undefined] 还有一个lookbehind的否定版本，用(?&lt;!...)，只有当模式前面没有lookbehind中的模式时，负lookbehind才允许您匹配模式。例如，模式/(?&lt;!un)available/匹配没有“un”前缀的可用词 这段翻译的不好，放上原文 There is also a negative version of lookbehind, which is denoted by (?&lt;!...). A negative lookbehind allows you to match a pattern only if it is not preceded by the pattern within the lookbehind. For example, the pattern /(?&lt;!un)available/ matches the word available if it does not have a “un” prefix: Unicode Property Escapes(Unicode属性转义)ES2018提供了一种称为Unicode属性转义的新类型转义序列，它在正则表达式中提供对完整Unicode的支持。假设您要在字符串中匹配Unicode字符㉛。虽然㉛被认为是一个数字，但是你不能将它与\\d速记字符类匹配，因为它只支持ASCII [0-9]字符。另一方面，Unicode属性转义可用于匹配Unicode中的任何十进制数： 1234const str = '㉛';console.log(/\\d/u.test(str)); // → falseconsole.log(/\\p&#123;Number&#125;/u.test(str)); // → true 同样，如果要匹配任何Unicode字母字符，你可以使用\\p{Alphabetic}： 123456const str = 'ض';console.log(/\\p&#123;Alphabetic&#125;/u.test(str)); // → true// the \\w shorthand cannot match ض console.log(/\\w/u.test(str)); // → false 还有一个否定版本\\p{...}，表示为\\P{...}： 12345console.log(/\\P&#123;Number&#125;/u.test('㉛')); // → falseconsole.log(/\\P&#123;Number&#125;/u.test('ض')); // → trueconsole.log(/\\P&#123;Alphabetic&#125;/u.test('㉛')); // → trueconsole.log(/\\P&#123;Alphabetic&#125;/u.test('ض')); // → false 除了字母和数字之外，还有几个属性可以在Unicode属性转义中使用。您可以在当前规范提案中找到支持的Unicode属性列表。 Support for New RegExp * Chrome Firefox Safari Edge S（DOTALL）标志 62 No 11.1 No 命名捕获组 64 No 11.1 No 后向断言 62 No No No Unicode属性转义 64 No 11.1 No * Chrome Android Firefox Android iOS Safari Edge Mobile Samsung Internet Android Webview S（DOTALL）标志 62 No 11.3 No 8.2 62 命名捕获组 64 No 11.3 No No 64 后向断言 62 No No No 8.2 62 Unicode属性转义 64 No 11.3 No No 64 Node.js 8.3.0 (运行时需要加-harmony) 8.10.0 (support for s (dotAll) flag and lookbehind assertions) 10.0.0 (完全支持) 模板字符串当模板字符串紧跟在表达式之后时，它被称为标记模板字符串。当您想要使用函数解析模板文字时，标记的模板会派上用场。请考虑以下示例： 1234567891011function fn(string, substitute) &#123; if(substitute === 'ES6') &#123; substitute = 'ES2015' &#125; return substitute + string[1];&#125;const version = 'ES6';const result = fn`$&#123;version&#125; was a major update`;console.log(result); // → ES2015 was a major update 在此代码中，调用标记表达式（它是常规函数）并传递模板文字。该函数只是修改字符串的动态部分并返回它。 在ES2018之前，标记的模板字符串具有与转义序列相关的语法限制。反斜杠后跟某些字符序列被视为特殊字符：\\x解释为十六进制转义符，\\u解释为unicode转义符，\\后跟一个数字解释为八进制转义符。其结果是，字符串，例如”C:\\xxx\\uuu“或者”\\ubuntu“被认为是由解释无效转义序列，并会抛出SyntaxError。 ES2018从标记模板中删除了这些限制，而不是抛出错误，表示无效的转义序列如下undefined 1234567function fn(string, substitute) &#123; console.log(substitute); // → escape sequences: console.log(string[1]); // → undefined&#125;const str = 'escape sequences:';const result = fn`$&#123;str&#125; \\ubuntu C:\\xxx\\uuu`; 请记住，在常规模板文字中使用非法转义序列仍会导致错误： 12const result = `\\ubuntu`;// → SyntaxError: Invalid Unicode escape sequence Support for Template Literal Revision Chrome Firefox Safari Edge 62 56 11 No Chrome Android Firefox Android iOS Safari Edge Mobile Samsung Internet Android Webview 62 56 11 No 8.2 62 Node.js 8.3.0 （运行时需要加-harmony） 8.10.0（完全支持） 总结我们已经仔细研究了ES2018中引入的几个关键特性，包括异步迭代，rest/spread属性Promise.prototype.finally()以及RegExp对象的添加。虽然其中一些浏览器供应商尚未完全实现其中一些功能，但由于像Babel这样的JavaScript转换器，它们今天仍然可以使用。 ECMAScript正在迅速发展，并且每隔一段时间就会引入新功能，因此请查看已完成提案的列表，了解新功能的全部内容。 第一次翻译文章，能力有限，水平一般，翻译不妥之处，还望指正。感谢。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yb909144903.github.io/categories/JavaScript/"}],"tags":[]},{"title":"react打怪笔记","slug":"react打怪笔记","date":"2018-12-19T08:39:01.000Z","updated":"2019-01-14T06:44:33.012Z","comments":true,"path":"2018/12/19/react打怪笔记/","link":"","permalink":"https://yb909144903.github.io/2018/12/19/react打怪笔记/","excerpt":"","text":"介绍本文为学习react中的记录。 Tips: 当组件的props或state有变化，执行render函数。 无论是使用函数或是类来声明一个组件，它决不能修改它自己的props React 可以将多个setState() 调用合并成一个调用来提高性能。 无状态函数式组件 (stateless functional component)React v16.7.0-alpha(内测) 将引入 Hooks, 这将意味着函数式组件将拥有类似类组件的特性。 无生命周期方法函数式组件，有时也被称为无状态组件，没有任何生命周期方法，意味着每次上层组件树状态发生变更时它们都会重新渲染，这就是因为缺少 shouldComponentUpdate 方法导致的。这也同样意味着您不能定义某些基于组件挂载和卸载的行为。 没有 this 和 ref更有趣的是您在函数式组件中既不能使用 this关键字或访问到 ref。对于习惯了严格意义上的类或面向对象风格的人来说，这很让他们惊讶。这也是使用函数最大的争论点。另一个有趣的事实就是您仍然可以访问到 context，如果您将 context 定义为函数的一个 props。 避免常见陷阱在编写无状态函数式组件时，您需要避免某些特定的模式。避免在函数式组件中定义函数，这是因为每一次函数式组件被调用的时候，一个新的函数都会被创建。 123456const Functional = (&#123;...&#125;) =&gt; &#123; const handleSomething = e =&gt; path(['event', 'target'], e) return ( // ... )&#125; 这个问题很容易解决，您可以将这个函数作为 props 传递进去，或者将它定义在组件外面。 12const handleSomething = e =&gt; path(['event', 'target'], e)const Functional = (&#123;...&#125;) =&gt; // ... 生命周期概况 生命周期演示 1.初始化在组件初始化阶段会执行 constructor static getDerivedStateFromProps() componentWillMount() / UNSAFE_componentWillMount() render() componentDidMount() 2.更新阶段props或state的改变可能会引起组件的更新，组件重新渲染的过程中会调用以下方法： componentWillReceiveProps() / UNSAFE_componentWillReceiveProps() static getDerivedStateFromProps() shouldComponentUpdate() componentWillUpdate() / UNSAFE_componentWillUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate() 3.卸载阶段 componentWillUnmount() 4.错误处理 componentDidCatch() 详解1.constructor(props)react组件的构造函数在挂载之前被调用。在实现React.Component构造函数时，需要先在添加其他内容前，调用super(props)，用来将父组件传来的props绑定到这个类中，使用this.props将会得到。 官方建议不要在constructor引入任何具有副作用和订阅功能的代码，这些应当在componentDidMount()中写入。 constructor中应当做些初始化的动作，如：初始化state，将事件处理函数绑定到类实例上，但也不要使用setState()。如果没有必要初始化state或绑定方法，则不需要构造constructor，或者把这个组件换成纯函数写法。 当然也可以利用props初始化state，在之后修改state不会对props造成任何修改，但仍然建议大家提升状态到父组件中，或使用redux统一进行状态管理。 123456constructor(props) &#123; super(props); this.state = &#123; color: props.initialColor &#125;;&#125; 2.static getDerivedStateFromProps(nextProps, prevState)getDerivedStateFromProps在组件实例化后，和接受新的props后被调用。他返回一个对象来更新状态，或者返回null表示新的props不需要任何state的更新。 如果是由于父组件的props更改，所带来的重新渲染，也会触发此方法。 调用steState()不会触发getDerivedStateFromProps()。 3. componentWillMount() / UNSAFE_componentWillMount()componentWillMount()将在react未来版本中被弃用。UNSAFE_componentWillMount()在组件挂载前被调用，在这个方法中调用setState()不会起作用，是由于他在render()前被调用。 为了避免副作用和其他的订阅，官方都建议使用componentDidMount()代替。这个方法是用于在服务器渲染上的唯一方法。 4.render()render()方法是必需的。当他被调用时，他将计算this.props和this.state，并返回以下一种类型： React元素。通过jsx创建，既可以是dom元素，也可以是用户自定义的组件。 字符串或数字。他们将会以文本节点形式渲染到dom中。 Portals。react 16版本中提出的新的解决方案，可以使组件脱离父组件层级直接挂载在DOM树的任何位置。 null，什么也不渲染 布尔值。也是什么都不渲染，通常后跟组件进行判断。 当返回null,false,ReactDOM.findDOMNode(this)将会返回null，什么都不会渲染。 render()方法必须是一个纯函数，他不应该改变state，也不能直接和浏览器进行交互，应该将事件放在其他生命周期函数中。如果shouldComponentUpdate()返回false，render()不会被调用。 Fragments你也可以在render()中使用数组，如：(不要忘记给每个数组元素添加key，防止出现警告)1234567render() &#123; return [ &lt;li key=\"A\"&gt;First item&lt;/li&gt;, &lt;li key=\"B\"&gt;Second item&lt;/li&gt;, &lt;li key=\"C\"&gt;Third item&lt;/li&gt;, ];&#125; 换一种写法，可以不写key（v16++）123456789render() &#123; return ( &lt;React.Fragment&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;/React.Fragment&gt; );&#125; 官方示例: 1234567891011121314151617function Clock(props) &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; );&#125;function tick() &#123; ReactDOM.render( &lt;Clock date=&#123;new Date()&#125; /&gt;, document.getElementById('root') );&#125;setInterval(tick, 1000); 5.componentWillReceiveProps()/UNSAFE_componentWillReceiveProps(nextProps)官方建议使用getDerivedStateFromProps函数代替componentWillReceiveProps()。当组件挂载后，接收到新的props后会被调用。如果需要更新state来响应props的更改，则可以进行this.props和nextProps的比较，并在此方法中使用this.setState()。 如果父组件会让这个组件重新渲染，即使props没有改变，也会调用这个方法。 react不会在组件初始化props时调用这个方法。调用this.setState也不会触发。 6.shouldComponentUpdate(nextProps, nextState)调用shouldComponentUpdate使react知道，组件的输出是否受state和props的影响。默认每个状态的更改都会重新渲染，大多数情况下应该保持这个默认行为。 在渲染新的props或state前，shouldComponentUpdate会被调用。默认为true。这个方法不会在初始化时被调用，也不会在forceUpdate()时被调用。返回false不会阻止子组件在state更改时重新渲染。 如果shouldComponentUpdate()返回false，componentwillupdate,render和componentDidUpdate不会被调用。 在未来版本，shouldComponentUpdate()将会作为一个提示而不是严格的指令，返回false仍然可能导致组件的重新渲染。官方并不建议在shouldComponentUpdate()中进行深度查询或使用JSON.stringify()，他效率非常低，并且损伤性能。 7.UNSAFE_componentWillUpdate(nextProps, nextState)在渲染新的state或props时，UNSAFE_componentWillUpdate会被调用，将此作为在更新发生之前进行准备的机会。这个方法不会在初始化时被调用。 不能在这里使用this.setState()，也不能做会触发视图更新的操作。如果需要更新state或props，调用getDerivedStateFromProps。 8.getSnapshotBeforeUpdate()在react render()后的输出被渲染到DOM之前被调用。它使您的组件能够在它们被潜在更改之前捕获当前值（如滚动位置）。这个生命周期返回的任何值都将作为参数传递给componentDidUpdate()。 9.componentDidUpdate(prevProps, prevState, snapshot)在更新发生后立即调用componentDidUpdate()。此方法不用于初始渲染。当组件更新时，将此作为一个机会来操作DOM。只要您将当前的props与以前的props进行比较（例如，如果props没有改变，则可能不需要网络请求），这也是做网络请求的好地方。 如果组件实现getSnapshotBeforeUpdate()生命周期，则它返回的值将作为第三个“快照”参数传递给componentDidUpdate()。否则，这个参数是undefined。 10.componentWillUnmount()在组件被卸载并销毁之前立即被调用。在此方法中执行任何必要的清理，例如使定时器无效，取消网络请求或清理在componentDidMount（）中创建的任何监听。 11.componentDidCatch(error, info)错误边界是React组件，可以在其子组件树中的任何位置捕获JavaScript错误，记录这些错误并显示回退UI，而不是崩溃的组件树。错误边界在渲染期间，生命周期方法以及整个树下的构造函数中捕获错误。 如果类组件定义了此生命周期方法，则它将成为错误边界。在它中调用setState()可以让你在下面的树中捕获未处理的JavaScript错误，并显示一个后备UI。只能使用错误边界从意外异常中恢复;不要试图将它们用于控制流程。详细 错误边界只会捕获树中下面组件中的错误。错误边界本身不能捕获错误。 为什么虚拟dom会提高性能?虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能。 具体实现步骤如下： 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了。 参考链接 参考文档 React v16.3.0: New lifecycles and context API React.Component mytac","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://yb909144903.github.io/categories/JavaScript/"}],"tags":[]},{"title":"给Hexo搭建的博客绑定域名","slug":"Hexo域名","date":"2018-12-02T07:25:54.000Z","updated":"2018-12-02T08:01:25.192Z","comments":true,"path":"2018/12/02/Hexo域名/","link":"","permalink":"https://yb909144903.github.io/2018/12/02/Hexo域名/","excerpt":"","text":"前言前几天利用闲置时间，利用hexo在GitHub上搭建了一个静态博客，那么既然是个人博客，当然要上自己的域名了。 step-1首先你得你得搭建 XXX.github.io 这样的博客，[hexo教程]。 step-2你的博客可以访问后，去阿里云、腾讯云等网站去注册个域名。 step-3获取博客的ip地址 Tips: 这一步主要为了解析域名，不获取IP的话，step4解析A类型就行 第一： clone 你创建的 仓库 xxx.github.io 第二： git的输入 ping www.xxx.github.io 得到IP 如下图： step-4等域名审核完后，和我相关的就来了。以下用阿里云注册的域名为例。进入阿里云的管理控制台-域名与网站-云解析DNS，进入域名的解析设置，点击新手指导，将得到的 IP 地址填到记录值一栏，点击确定就 OK 了。填完以后的解析列表会出现： 记录值就是自己 github 的二级域名的 IP地址。 Tips: 一般解析都需要点时间，等个20分钟左右就好了 step-5在hexo项目下 source 文件下创建CNAME 文件（没有后缀名的），在里面写上购买的域名，例如： step-6最后到你 xxx.github.io 的Settings里，填上你的域名 这样新域名就ok啦，可以访问了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://yb909144903.github.io/categories/Hexo/"}],"tags":[]},{"title":"Git中遇到的大大小小的坑","slug":"Git","date":"2018-11-29T12:41:49.000Z","updated":"2019-01-09T12:44:12.510Z","comments":true,"path":"2018/11/29/Git/","link":"","permalink":"https://yb909144903.github.io/2018/11/29/Git/","excerpt":"","text":"目的：记录自己平时在项目中遇到的坑 Tips 不要在dev上操作。 更新git: git update- 1.windows清除git保存账号信息步骤因为做项目可能会用到不同的gitLab远程库，我的git默认是记住密码的，当时困扰了我好久，项目中的一个大佬，告诉的我这种方法。 开始菜单-&gt;控制面板-&gt;凭据管理器-&gt;windows凭据-&gt;从保管库中删除. 如图： 2.Git修改文件名大小写时不更新如果使用windows系统Coding，使用git时,如果一个文件只是把文件名的大小写改一下,提交后默认更新下来还是改之前的情况。通过谷歌，我找到以下两种方案。 通过修改”core.ignorecase false”来设置git大小写敏感.需要在提交端修改. git config core.ignorecase false 先删除文件再添加进去 git rmgit add.git commit -m “rename file” 终极解决方案 3.平时项目中git的基本操作暂存修改的文件 git add [fileName] ——暂存某个文件git add . ——暂存所有修改的文件 撤销本地修改文件 git checkout [fileName] ——撤销某个文件git checkout . ——撤销所有修改的文件 提交暂存区文件 fix：修复bug update：更新文件 add：新增文件 modify：重命名 delete：删除文件 git commit -m “你的提交备注” 不想commit，那就储藏 git stash ——储藏git stash pop/apply ——弹出储藏git stash save ‘message’ ——储藏是加messagegit stash drop stash@{$num} ——丢弃stash@{$num}存储，从列表中删除这个存储git stash clear –删除所有缓存的stash 将本地仓库的代码推到远程分支 git push [远程分支名] 切换分支 git checkout [你要切换的分支名] 注释：切换分支之前，一定要将修改的文件提交或者放进储藏区 拉取远程分支代码 git pull orgin [分支名]git pull ——拉取当前分支的代码 合并分支 git merge [你要合并的分支名] 查看本地分支 git branch 查看远程分支 git branch -a 删除本地分支 git branch -d/-D [你要删除的分支] 删除远程分支 git branch orgin –delete [你要删除掉的分支] 查看提交记录 git loggit log -5 查看五条记录 查看被删除的提交记录 git reflog 回滚代码 git reset [commitId] 回滚代码但修改的代码还在git reset –hard [commitId] 回滚代码且修改的代码也没了 推送代码 git push orgin [当前分支]:devlop 连接远程仓库 git remote add origin 仓库地址仓库地址：https://git.coding.net/xxxxxxxxxxxxx/my-project.gitgit push -u orgin master 删除远程仓库 git remote remove origin 因为这篇文章属于我自己的记录，有的为别人博客的内容。侵权必删","categories":[{"name":"Git","slug":"Git","permalink":"https://yb909144903.github.io/categories/Git/"}],"tags":[]},{"title":"三分钟教你同步 visual studio code 设置","slug":"vscode","date":"2018-11-28T11:57:11.000Z","updated":"2018-11-29T08:28:51.808Z","comments":true,"path":"2018/11/28/vscode/","link":"","permalink":"https://yb909144903.github.io/2018/11/28/vscode/","excerpt":"","text":"简介Visual Studio Code(以下简称vsCode)现在已经渐渐成为前端开发的主力工具，谁让它这么轻便，功能又这么轻便呢。用vscode Coding的小伙伴们也一定会装很多插件吧。但是当你准备更换电脑的时候，是不是为迁移插件和设置而烦恼？我曾经换电脑的时候，把vsCode上自己心爱的插件一个个记下，然后去新电脑上重装，太蠢了。今天我就把vsCode同步设置和插件的方法告诉大家。 准备工作 下载Settings Sync插件 GitHub账号 1.安装Settings Sync Setting Sync 快捷键： 1) 上传： Shift + Alt + U (Sync: Update / Upload Settings) 2) 下载： Shift + Alt + D (Sync: Download Settings) 如果快捷键有冲突，可Ctrl + K + S快捷键设置配置其它快捷键 或 Ctrl + P / F1 在命令窗口输入 &gt;sync 即会出现相应命令供选择 2.打开GitHub 这样你就得到一个token，最好找个地方记下来。因为它就是同步设置的关键。 3.将token配置到vsCode(Sync: Update / Uplaod Settings) Shift + Alt + U 在弹窗里输入你的token， 回车后会生成syncSummary.txt文件 syncSummary.txt文件会存储VSCode的设置及所安装的插件列表 如果你使用的是新版本的vsCode 打开设置，在搜索框中输入sync，就可以看到自己的token了 4.设置同步下载设置(Sync: Download Settings) Shift + Alt + D 在弹窗里输入你的gist值，稍后片刻便可同步成功 5.如果要重置同步设置，变更其它tokenCtrl+P / F1 弹出输入&gt;sync,即可重新配置你的其它token来同步 6.Tips上传同步设置的时候，vsCode底下可以看到操作信息 Setting Sync 可同步包含的所有扩展和完整的用户文件夹 1) 设置文件 2) 快捷键设置文件 3) Launch File 4) Snippets Folder 5) VSCode 扩展设置 6) 工作空间 参考文章 Settings Sync更新说明","categories":[{"name":"工具资源","slug":"工具资源","permalink":"https://yb909144903.github.io/categories/工具资源/"}],"tags":[]}]}