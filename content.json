{"meta":{"title":"Timbok's Blog","subtitle":"Timbok's BLOG","description":"一个前端的技术博客，偶尔也会分享一些好的文章和行业趣事。","author":"Timbok","url":"https://timbok.github.io"},"pages":[{"title":"文章分类","date":"2018-11-29T08:08:09.000Z","updated":"2020-04-15T12:16:58.184Z","comments":false,"path":"categories/index.html","permalink":"https://timbok.github.io/categories/index.html","excerpt":"","text":""},{"title":"个人简历","date":"2019-01-04T16:00:00.000Z","updated":"2020-09-14T07:14:22.302Z","comments":true,"path":"introduce/index.html","permalink":"https://timbok.github.io/introduce/index.html","excerpt":"","text":"Timbok(timbok.yang@qq.com)个人信息 学历：本科 专业：软件工程 职业：前端攻城狮 发量：茂盛 技术博客：https://timbok.top 地点： 上海 项目经历 ████████████████████ ████████████████████ ████████████████████ ████████████████████ 技能列表 熟悉vueJS、React等主流MVC、MVVM框架； 掌握localStorage、sessionStorage等前端存储方案，记录用户操作习惯或常用数据，从而降低HTTP请求，提升用户体验； 熟练使用SVN、git版本控制工具，进行代码管理，实现敏捷开发； 熟练使用Bootstarp框架，通过栅格系统快速布局响应式页面以适应 不同设备； 熟练使用Ajax，实现异步页面无刷新抽取数据，同步校验数据； 熟练使用HTML、CSS、JavaScript等前端技术，完成网页静态布局， 开发兼容主流浏览器的页面，以及实现页面的交互，提升用户体验； 了解node.js，利用其搭建简单的服务器。 个人爱好 吃饭、睡觉、打豆豆 玩游戏 运动"},{"title":"留言板","date":"2019-01-04T16:00:00.000Z","updated":"2020-04-15T12:16:58.185Z","comments":true,"path":"message/index.html","permalink":"https://timbok.github.io/message/index.html","excerpt":"","text":"欢迎留言，相互交流。🙄🙄🙄"},{"title":"Daily Sharing","date":"2019-01-04T16:00:00.000Z","updated":"2020-07-17T02:39:29.063Z","comments":true,"path":"share/index.html","permalink":"https://timbok.github.io/share/index.html","excerpt":"","text":"好文推荐技术 lodash的debounce,bind和es7的@装饰器 this、apply、call、bind 手把手教你撸一个简易的 webpack JavaScript开发者应懂的33个概念 如何编写高质量的函数 狼叔：如何正确的学习Node.js 七天学会Node.js 每日一道面试题 Javascript 面试中经常被问到的三个问题！ 娱乐 免费的在线影视网站汇总 免费下载电影 免费下载win软件 下载各种音效 下载好看的字体"}],"posts":[{"title":"一个入门总结","slug":"一个入门总结","date":"2020-10-08T02:48:14.000Z","updated":"2021-01-27T02:37:48.998Z","comments":true,"path":"2020/10/08/一个入门总结/","link":"","permalink":"https://timbok.github.io/2020/10/08/一个入门总结/","excerpt":"","text":"基础学习资料HTML5/CSS3 HTML（超文本标记语言） JavaScript（ES5） JavaScript教程 ES6 ES6 入门教程 Vue Vue.js 基础学习完后，可以选择一个框架，推荐Vue（本菜鸟更精通React）Vue文档国人写的，好理解！市场需求也大！ 在学习基础资料的时候一定要做笔记，切不可囫囵吞枣！笔记可以使用md来写！md语法教程 Markdown基本语法有道云笔记支持md，建议使用 在学习中除了笔记，肯定还有一些代码实例。这时候可以顺带把git学了在GitHub/码云等网站建立一个私人仓库，把你的代码每天的代码提交到每天建立的分支，然后统一合并到主分支。 Git Git - Book Git不用特意学，哪里不会，去查看了解清楚！ 论坛掘金 掘金 - juejin.im - 一个帮助开发者成长的社区 适合有一定基础去看文档思否 SegmentFault 思否 有一些优质的入门教程stackoverflow 各种疑难杂症都有解答的神奇网站 需要梯子github Github 全球最大同人网站不用我多说了吧论坛不用多刷，写把基础学好 总结学计算机挺好的，就是头有点冷！","categories":[{"name":"工具资源","slug":"工具资源","permalink":"https://timbok.github.io/categories/工具资源/"}],"tags":[]},{"title":"JavaScript4种常用的数组去重","slug":"JavaScript4种常用的数组去重","date":"2020-06-18T02:22:57.000Z","updated":"2020-06-18T03:04:29.157Z","comments":true,"path":"2020/06/18/JavaScript4种常用的数组去重/","link":"","permalink":"https://timbok.github.io/2020/06/18/JavaScript4种常用的数组去重/","excerpt":"","text":"数组去重面试中或者开发经常会问到数组去重，整理了我知道的四种。还有什么新方法，新操作，欢迎补充！ 1var arr = [1, 1, '1', '1', 'true', 'true', true, true, null, null, undefined, undefined, NaN, NaN, &#123;'a': 1&#125;, &#123;'a': 1&#125;] 1. ES6去重{}不能去重12Array.from(new Set(arr))// (9) [1, \"1\", \"true\", true, null, undefined, NaN, &#123;…&#125;, &#123;…&#125;] 2. 双重遍历去重{}、NaN不能去重，可做特殊操作实现1234567891011function unique(arr = []) &#123; for(let i = 0; i &lt; arr.length; i++) &#123; for(let j = i + 1; j &lt; arr.length; j++) &#123; if(arr[i] === arr[j]) &#123; arr.splice(j, 1); j--; &#125; &#125; &#125;&#125;// (10) [1, \"1\", \"true\", true, null, undefined, NaN, NaN, &#123;…&#125;, &#123;…&#125;] 3. indexOf 或者 includes 去重需要注意的是 includes 可以去除NaN，而 indexOf 不可以。 arr.indexOf(NaN) === -1 1234567891011function unique(arr = []) &#123; let newArr = []; for(let i = 0; i &lt; arr.length; i++) &#123; debugger; if(!newArr.includes(arr[i]) || newArr.indexOf(arr[i]) === -1) &#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;// (10) [1, \"1\", \"true\", true, null, undefined, NaN, NaN, &#123;…&#125;, &#123;…&#125;] 4. filter去重原理：indexOf只会返回在数组中第一次出现的元素位置 1234arr.filter((item, index, arr) =&gt; &#123; return arr.indexOf(item) === index;&#125;)(8) [1, \"1\", \"true\", true, null, undefined, &#123;…&#125;, &#123;…&#125;]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://timbok.github.io/categories/JavaScript/"}],"tags":[]},{"title":"commit格式化代码并校验","slug":"commit格式化代码并校验","date":"2020-05-08T03:13:18.000Z","updated":"2020-05-08T03:14:06.362Z","comments":true,"path":"2020/05/08/commit格式化代码并校验/","link":"","permalink":"https://timbok.github.io/2020/05/08/commit格式化代码并校验/","excerpt":"","text":"commit格式化代码并校验借助 git hooks 中的 pre-commit 实现 安装 husky 和 lint-stagedyarn add husky lint-staged --dev 配置 husky 和 lint-staged在package.json中修改 123456789101112\"husky\": &#123; \"hooks\": &#123; \"pre-commit\": \"lint-staged\" &#125;&#125;,\"lint-staged\": &#123; \"src/**/*.&#123;js,jsx,ts,tsx&#125;\": \"eslint --quiet --fix --ext .js\", \"src/**/*.less\": \"stylelint --syntax less\", \"src/**/*.&#123;js,jsx,ts,tsx,less&#125;\": [ \"prettier --write\" ]&#125; git hooks 文档","categories":[{"name":"工具资源","slug":"工具资源","permalink":"https://timbok.github.io/categories/工具资源/"}],"tags":[]},{"title":"原型和原型链","slug":"原型和原型链","date":"2020-05-08T03:05:27.000Z","updated":"2020-05-08T03:05:49.616Z","comments":true,"path":"2020/05/08/原型和原型链/","link":"","permalink":"https://timbok.github.io/2020/05/08/原型和原型链/","excerpt":"","text":"原型和原型链原型在 JavaScript 中，函数（function）是允许拥有属性的。所有的函数会有一个特别的属性 —— prototype，这个属性就是原型，它是一个对象。 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中 1234567891011function Person(name, age) &#123; this.name = name; this.age = age; this.sayName = function() &#123; return this.name; &#125;&#125;var timbok = new Person('timbok', 18);var lucy = new Person('lucy', 20);console.log(timbok.sayName === lucy.sayName); // false 可以看到，对于同一个函数，我们通过 new 生成出来的实例，都会开出新的一块堆区，所以上面代码中 timbok 和 lucy的sayName不相等。 当使用prototype时 1234567Person.prototype.eat = function() &#123; console.log('吃');&#125;var timbok = new Person('timbok', 18);var lucy = new Person('lucy', 20);console.log(timbok.eat === lucy.eat); // true 原型链在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。 123Person.prototype.constructor === Person // truePerson.prototype === timbok.__proto__ // true 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined。 123456Person.prototype.a = 123;var person = new Person()console.log(person.a) // 123console.log(person.b) // undefined person.a: 先在person对象里找a -&gt; 没找到会再到person.__proto__，也就是 Person.prototype内找 -&gt; 找到了 person.b: 先在person对象里找b -&gt; 没找到会再到person.__proto__内找 -&gt; 查找与对象关联的原型中的属性 -&gt; 找原型的原型，一直找到最顶层Object为止 -&gt; 找不到就undefined 衍生扩展-new操作符要想弄懂new，得先了解一下何为构造函数？ 构造函数构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数 用以下的例子来模仿 var person = new Person() 的过程 12345678910111213141516171819202122// 1. 需要一个创造器function Creator() &#123; this.name='creator' console.log(\"创造器\");&#125;// 2. 新建变量，开辟内存var person = &#123;&#125;;// 3. 通过 __proto__ 指向Creator的原型person.__proto__ = Creator.prototype// 4. call person 使其可以扩展nameCreator.call(person) // 创造器// 5.在原型上增加方法Creator.prototype.action = function() &#123; console.log('创造动作')&#125;person.action() // 创造动作console.log(person) // Creator &#123;name: 1&#125; 关于 this、apply、call、bind 可以看这篇文章。 写在最后个人总结，如有不正确，欢迎指正！","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://timbok.github.io/categories/JavaScript/"}],"tags":[]},{"title":"typescript学习小记","slug":"typescript学习小记","date":"2020-05-01T02:20:15.000Z","updated":"2020-05-08T03:08:11.850Z","comments":true,"path":"2020/05/01/typescript学习小记/","link":"","permalink":"https://timbok.github.io/2020/05/01/typescript学习小记/","excerpt":"","text":"Tips可选参数?: 1234567interface Person &#123; gender?: string; // 可选属性&#125;function sayHello(person: string, age?: number): string &#123; return `Hello, $&#123;person&#125;. I am $&#123;age&#125;`;&#125; 报错类型“Readonly&lt;{}&gt; &amp; Readonly&lt;{ children?: ReactNode; }&gt;”上不存在属性“history”。ts(2339)ts直接引用路由会报如上的错 1const &#123; history: &#123; location: &#123; pathname &#125; &#125; &#125; = this.props; 引用下 RouteComponentProps 即可 12345678import &#123; RouteComponentProps &#125; from 'react-router-dom';export default class Home extends Component&lt;RouteComponentProps&gt; &#123; render() &#123; const &#123; history: &#123; location: &#123; pathname &#125; &#125; &#125; = this.props; return &lt;div className=&#123;style.test&#125;&gt;这是&#123;pathname&#125;&lt;/div&gt;; &#125;&#125; 找不到模块“./index.module.less”。ts(2307)在 global.d.ts 里声明： 1234declare module '*.module.less' &#123; const classes: &#123; readonly [key: string]: string &#125;; export default classes;&#125; 注意：函数的可选参数必须放在必需后 基本类型空值 void声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null：let unusable: void = undefined; Null 和 Undefined在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型： 12let u: undefined = undefined;let n: null = null; 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量： 12// 这样不会报错let num: number = undefined; 联合类型联合类型（Union Types）表示取值可以为多种类型中的一种。 联合类型使用 | 分隔每个类型。1234let num: number | string;num = 6;num = 'six'; 函数重载123456789function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string &#123; if (typeof x === 'number') &#123; return Number(x.toString().split('').reverse().join('')); &#125; else if (typeof x === 'string') &#123; return x.split('').reverse().join(''); &#125;&#125; 上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。 注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。 类型断言 联合类型可以被断言为其中一个类型 父类可以被断言为子类 任何类型都可以被断言为 any any 可以被断言为任何类型 声明文件全局变量的声明文件主要有以下几种语法： declare var 声明全局变量 declare function 声明全局方法 declare class 声明全局类 declare enum 声明全局枚举类型 declare namespace 声明（含有子属性的）全局对象 interface 和 type 声明全局类型 npm 包发布到 @types 里。我们只需要尝试安装一下对应的 @types 包就知道是否存在该声明文件，安装命令是 npm install @types/foo --save-dev。这种模式一般是由于 npm 包的维护者没有提供声明文件，所以只能由其他人将声明文件发布到 @types 里了。 类型别名类型别名用来给一个类型起个新名字。使用type 12345678type stringOrNumber = string | Function;function getName(n: stringOrNumber): stringOrNumber &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125;&#125; 字符串字面量类型字符串字面量类型用来约束取值只能是某几个字符串中的一个。 123456789type EventNames = 'click' | 'scroll' | 'mousemove';function handleEvent(ele: Element, event: EventNames) &#123; // do something&#125;handleEvent(document.getElementById('hello'), 'scroll'); // 没问题handleEvent(document.getElementById('world'), 'dbclick'); // 报错，event 不能为 'dbclick'// index.ts(7,47): error TS2345: Argument of type '\"dbclick\"' is not assignable to parameter of type 'EventNames'. 枚举枚举（Enum）类型用于取值被限定在一定范围内的场景 枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射： 1234567891011enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days[\"Sun\"] === 0); // trueconsole.log(Days[\"Mon\"] === 1); // trueconsole.log(Days[\"Tue\"] === 2); // trueconsole.log(Days[\"Sat\"] === 6); // trueconsole.log(Days[0] === \"Sun\"); // trueconsole.log(Days[1] === \"Mon\"); // trueconsole.log(Days[2] === \"Tue\"); // trueconsole.log(Days[6] === \"Sat\"); // true 事实上，上面的例子会被编译为： 12345678910var Days;(function (Days) &#123; Days[Days[\"Sun\"] = 0] = \"Sun\"; Days[Days[\"Mon\"] = 1] = \"Mon\"; Days[Days[\"Tue\"] = 2] = \"Tue\"; Days[Days[\"Wed\"] = 3] = \"Wed\"; Days[Days[\"Thu\"] = 4] = \"Thu\"; Days[Days[\"Fri\"] = 5] = \"Fri\"; Days[Days[\"Sat\"] = 6] = \"Sat\";&#125;)(Days || (Days = &#123;&#125;)); 枚举项只能被赋值为常数 类实现接口实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性。 举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它： 123456789101112131415161718interface Alarm &#123; alert(): void;&#125;class Door &#123;&#125;class SecurityDoor extends Door implements Alarm &#123; alert() &#123; console.log('SecurityDoor alert'); &#125;&#125;class Car implements Alarm &#123; alert() &#123; console.log('Car alert'); &#125;&#125; 泛型泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 123456789function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray&lt;string&gt;(3, 'x'); // ['x', 'x', 'x'] 上例中，我们在函数名后添加了 &lt;T&gt;，其中 T 用来指代任意输入的类型，在后面的输入 value: T 和输出 Array&lt;T&gt; 中即可使用了。 资料: https://ts.xcatliu.com/","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://timbok.github.io/categories/JavaScript/"}],"tags":[]},{"title":"Hook学习小记","slug":"Hook学习小记","date":"2020-04-18T02:26:16.000Z","updated":"2020-05-08T03:13:04.615Z","comments":true,"path":"2020/04/18/Hook学习小记/","link":"","permalink":"https://timbok.github.io/2020/04/18/Hook学习小记/","excerpt":"","text":"HookHook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 Hook是什么Hook 是一个特殊的函数，它可以让你“钩入” React 的特性。例如，useState 是允许你在 React 函数组件中添加 state 的 Hook。 注意 可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合。 useEffect 会在每次渲染后都执行 为什么要在 effect 中返回一个函数？ 这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。如果你的 effect 返回一个函数，React 将会在执行清除操作时调用它 Hook 规则只在最顶层使用 Hook不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。 只在 React 函数中调用 Hook不要在普通的 JavaScript 函数中调用 Hook。 增加Eslint 校验以上两条规则npm install eslint-plugin-react-hooks --save-dev 123456789101112// 你的 ESLint 配置&#123; \"plugins\": [ // ... \"react-hooks\" ], \"rules\": &#123; // ... \"react-hooks/rules-of-hooks\": \"error\", // 检查 Hook 的规则 \"react-hooks/exhaustive-deps\": \"warn\" // 检查 effect 的依赖 &#125;&#125; React Hooks 详解","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://timbok.github.io/categories/JavaScript/"}],"tags":[]},{"title":"React冷门但很好用的知识点","slug":"React冷门但很好用的知识点","date":"2019-08-27T13:00:03.000Z","updated":"2020-04-15T12:16:58.179Z","comments":true,"path":"2019/08/27/React冷门但很好用的知识点/","link":"","permalink":"https://timbok.github.io/2019/08/27/React冷门但很好用的知识点/","excerpt":"","text":"介绍最近在重读React官方文档，盘点一些不常用但有用的知识点。如果有啥说的不好的地方，欢迎指正！ 推荐个翻译的不错的React文档 getSnapshotBeforeUpdate()getSnapshotBeforeUpdate()为React生命周期函数， 在render()之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 componentDidUpdate()。 处理聊天滚动的示例：1234567891011121314151617181920212223242526272829303132class ScrollingList extends React.Component &#123; constructor(props) &#123; super(props); this.listRef = React.createRef(); &#125; getSnapshotBeforeUpdate(prevProps, prevState) &#123; // 我们是否在 list 中添加新的 items ？ // 捕获滚动位置以便我们稍后调整滚动位置。 if (prevProps.list.length &lt; this.props.list.length) &#123; const list = this.listRef.current; return list.scrollHeight - list.scrollTop; &#125; return null; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; // 如果我们 snapshot 有值，说明我们刚刚添加了新的 items， // 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。 //（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值） if (snapshot !== null) &#123; const list = this.listRef.current; list.scrollTop = list.scrollHeight - snapshot; &#125; &#125; render() &#123; return ( &lt;div ref=&#123;this.listRef&#125;&gt;&#123;/* ...contents... */&#125;&lt;/div&gt; ); &#125;&#125; forceUpdate()默认情况下，当组件的 state 或 props 发生变化时，组件将重新渲染。如果 render() 方法依赖于其他数据，则可以调用 forceUpdate() 强制让组件重新渲染。 调用 forceUpdate() 将致使组件调用 render() 方法，此操作会跳过该组件的 shouldComponentUpdate()。但其子组件会触发正常的生命周期方法，包括 shouldComponentUpdate() 方法。如果标记发生变化，React 仍将只更新 DOM。 简单来说forceUpdate()方法可以强制更新组件，所以不建议使用！ keykey顾名思义为组件的标识，当key改变时组件会重新注册！但我们使用最多的还是遍历！ 1234567const todos = [1, 2, 3, 4, 5];const todoItems = todos.map((todo, index) =&gt; // Only do this if items have no stable IDs &lt;li key=&#123;index&#125;&gt; &#123;todo.text&#125; &lt;/li&gt;); 其实用index作为Key有问题，可以看这篇博客 状态提升官方解释：通常，多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去。 简单来说，就是两个子组件都使用父组件的一个参数，通过props把改参数传入子组件，并把改变该参数的方法一并传入子组件，通过调用该方法改变父组件共用的参数！ 举个例子🌰 现在有ComponentA以及ComponentB，他们各有一个输入框，当我在其中一个输入框输入英文单词时，在另一个组件展示转换后的大小写。 12345678910111213141516class ComponentA extends React.Component &#123; // 当input输入时，在另一个组件显示大的大小写转换 handleChange(e) =&gt; &#123; const &#123; onChangeWordUpper &#125; = this.props; onChangeWordUpper(e.target.value); &#125;; render() &#123; const &#123; word &#125; = this.props; return ( &lt;h2&gt;ComponentA enter: &#123;word&#125;&lt;/h2&gt; &lt;input onChange=&#123;this.handleChange&#125; /&gt; ); &#125;&#125;` 12345678910111213141516class ComponentB extends React.Component &#123; // 当input输入时，在另一个组件显示大的大小写转换 handleChange(e) =&gt; &#123; const &#123; onChangeWordLower &#125; = this.props; onChangeWordLower(e.target.value); &#125;; render() &#123; const &#123; word &#125; = this.props; return ( &lt;h2&gt;ComponentB enter: &#123;word&#125;&lt;/h2&gt; &lt;input onChange=&#123;this.handleChange&#125; /&gt; ); &#125;&#125;` 父组件componentFather 123456789101112131415161718192021222324252627282930313233class ComponentFather extends React.Component &#123; state = &#123; word: ''; &#125; // 转换为大写 onChangeWordUpper(value) =&gt; &#123; const word = value.toUpperCase() this.setState(&#123; word &#125;); &#125; // 转换为小写 onChangeWordLower(value) =&gt; &#123; const word = value.toLowerCase()() this.setState(&#123; word &#125;); &#125; render() &#123; const &#123; word &#125; = this.state; const componentAProps = &#123; word, onChangeWordUpper: this.onChangeWordUpper, &#125;; const componentBProps = &#123; word, onChangeWordUpper: this.onChangeWordLower, &#125;; return ( &lt;ComponentA &#123;...componentAProps&#125; /&gt; &lt;ComponentB &#123;...componentBProps&#125; /&gt; ); &#125;&#125; FragmentsFragments大家应该都很熟悉！ React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点 1234&lt;React.Fragment&gt; &lt;div&gt;somethings&lt;/div&gt; &lt;div&gt;somethings&lt;/div&gt;&lt;/React.Fragment&gt; 可以简写为 1234&lt;&gt; &lt;div&gt;somethings&lt;/div&gt; &lt;div&gt;somethings&lt;/div&gt;&lt;/&gt; children prop当一个组件无法知晓子组件的内容时，children prop就很有用。 它可以把子组件整个传递下去！ 举个例子🌰1234567891011121314151617// 父组件function Header(props) &#123; return ( &lt;div&gt; &#123;props.children&#125; &lt;/div&gt; );&#125;function Page() &#123; return ( &lt;Header&gt; &lt;h1&gt;children - 1&lt;/h1&gt; &lt;h1&gt;children - 2&lt;/h1&gt; &lt;/Header&gt; );&#125; 这样Header组件接受的children就是两个h1标签 ContextContext应该是很常用的Api，防止有人没使用过并巩固一下我的知识点，还是写一下。 举个例子🌰123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import React, &#123; createContext &#125; from \"react\";import ReactDOM from \"react-dom\";const ThemeContext = createContext(\"red\");class App extends React.Component &#123; state = &#123; color: \"green\" &#125;; handleChangeColor = () =&gt; &#123; if(this.state.color === 'green') &#123; this.setState(&#123; color: \"red\" &#125;); &#125; else &#123; this.setState(&#123; color: \"green\" &#125;); &#125; &#125;; render() &#123; // 使用一个 Provider 来将当前的 color 传递给以下的组件树。 // 无论多深，任何组件都能读取这个值。 // 在这个例子中，我们将 “dark” 作为当前的值传递下去。 return ( &lt;ThemeContext.Provider value=&#123;this.state.color&#125;&gt; &lt;Toolbar /&gt; &lt;br /&gt; &lt;button onClick=&#123;this.handleChangeColor&#125;&gt;changeColor&lt;/button&gt; &lt;/ThemeContext.Provider&gt; ); &#125;&#125;// 中间的组件再也不必指明往下传递 color 了。function Toolbar(props) &#123; return &lt;ThemedSpan /&gt;;&#125;class ThemedSpan extends React.Component &#123; // 指定 contextType 读取当前的 color context。 // React 会往上找到最近的 color Provider，然后使用它的值。 // 在这个例子中，当前的 color 值为 “green”。 static contextType = ThemeContext; render() &#123; return &lt;Span color=&#123;this.context&#125; /&gt;; &#125;&#125;class Span extends React.Component &#123; static contextType = ThemeContext; render() &#123; return ( &lt;span style=&#123;&#123; backgroundColor: this.props.color &#125;&#125;&gt;&#123;this.context&#125;&lt;/span&gt; ); &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(\"container\")); 注意事项：Provider的value我放在了state里。这样当value更新时不会导致其他组件渲染。 假设，value传入的是一个对象。12345// badconst obj = &#123;a: 1&#125;;&lt;ThemeContext.Provider value=&#123;obj&#125;&gt; &lt;Toolbar /&gt;&lt;/ThemeContext.Provider&gt; 当obj改变，但obj.a 还是 1，实际上，a的value并没有改变，但是obj !== obj。 但是this.state.obj === this.state.obj 1234// good&lt;ThemeContext.Provider value=&#123;this.state.obj&#125;&gt; &lt;Toolbar /&gt;&lt;/ThemeContext.Provider&gt; codesandbox地址 未完待续","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://timbok.github.io/categories/JavaScript/"}],"tags":[]},{"title":"stompJs出现TextEncoder is not defined解决方法","slug":"stompJs出现TextEncoder is not defined解决方法","date":"2019-08-12T08:48:12.000Z","updated":"2020-04-15T12:16:58.181Z","comments":true,"path":"2019/08/12/stompJs出现TextEncoder is not defined解决方法/","link":"","permalink":"https://timbok.github.io/2019/08/12/stompJs出现TextEncoder is not defined解决方法/","excerpt":"","text":"介绍上周在实现一个聊天的业务时，测试发现该功能在IE和Edge下是不能实现。在查看报错之后发现报错 Unhandled promise rejection ReferenceError: &#39;TextEncoder&#39; is not defined。原来是stompJs使用了TextEncoder方法，但IE和Edge的JavaScript运行环境不支持该方法。我找到了以下几种方法。只针对SPA应用 正文In NodeJs如果你的NodeJs版本升到了v11，那么node的运行环境是支持TextEncoder方法的。但是如果你的项目的nodeJs版本低于v11，可以安装moduletext-encodin。 $ npm install text-encoding 加在入口文件123456// These have been added in NodeJS v11, so good idea is to check firstif (typeof TextEncoder !== &apos;function&apos;) &#123; const TextEncodingPolyfill = require(&apos;text-encoding&apos;); window.TextEncoder = TextEncodingPolyfill.TextEncoder; window.TextDecoder = TextEncodingPolyfill.TextDecoder;&#125; WebSocket因为第一种方法解决了我的方法，所以一下方法没有去实践。 据了解有两个备用库websocket和ws可以使用。 websocket $ npm install websocket 在全局对象global中添加 Object.assign(global, { WebSocket: require(&#39;websocket&#39;).w3cwebsocket }); ws $ npm install ws Object.assign(global, { WebSocket: require(&#39;ws&#39;) });","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://timbok.github.io/categories/JavaScript/"}],"tags":[]},{"title":"Mac实现iTerm2 免登录ssh服务器","slug":"Mac实现iTerm2 免登录ssh服务器","date":"2019-07-23T03:43:09.000Z","updated":"2020-04-15T12:16:58.178Z","comments":true,"path":"2019/07/23/Mac实现iTerm2 免登录ssh服务器/","link":"","permalink":"https://timbok.github.io/2019/07/23/Mac实现iTerm2 免登录ssh服务器/","excerpt":"","text":"没图自己想象在你电脑的任意位置创建自动登录的脚本 touch itermSsh.sh vim itermSsh.sh shell12345678910#!/usr/bin/expect -fset user _userset host _hostset password _passwordset timeout -1spawn ssh $user@$hostexpect &quot;*assword:*&quot;send &quot;$password\\r&quot;interactexpect eof tip：替换_user用户名, _host服务器地址, _password密码 打开iTerm的Preferences -&gt; 切换到Profiles Tab -&gt; new profile -&gt; 在Command那一个输入框内写上itermSsh.sh的路径就可以。 然后new Tab的时候选择你创建的profile","categories":[{"name":"工具资源","slug":"工具资源","permalink":"https://timbok.github.io/categories/工具资源/"}],"tags":[]},{"title":"Summary and Prospect","slug":"Summary and Prospect","date":"2019-07-09T02:33:10.000Z","updated":"2020-04-15T12:16:58.179Z","comments":true,"path":"2019/07/09/Summary and Prospect/","link":"","permalink":"https://timbok.github.io/2019/07/09/Summary and Prospect/","excerpt":"","text":"目的记录自己的目标以及完成的事件！ 📝 Time - 20182018总结 面试成功，开始工作 学习了React、Git、ES6等技术 写了五篇很水的技术博客 在掘金阅读了1345篇文章 可以用工资养活自己 认识了很多优秀的人 2019展望 顺利毕业 提高学习能力 学习一门后端语言 多写技术博客 头发依旧茂密 📝 Time - 20192019年中回顾 毕业证 ✅ 学位证 ✅ 驾驶证 ✅ 头发依旧茂密 ✅ 提高学习能力 ❌ 学习一门后端语言 ❌ 多写技术博客 ❌","categories":[{"name":"杂记和随笔","slug":"杂记和随笔","permalink":"https://timbok.github.io/categories/杂记和随笔/"}],"tags":[]},{"title":"一棵开花的树","slug":"一棵开花的树","date":"2019-06-04T07:56:44.000Z","updated":"2020-04-15T12:16:58.183Z","comments":true,"path":"2019/06/04/一棵开花的树/","link":"","permalink":"https://timbok.github.io/2019/06/04/一棵开花的树/","excerpt":"","text":"《一棵开花的树》 - 席慕蓉如何让你遇见我在我最美丽的时刻 为这我已在佛前求了五百年求佛让我们结一段尘缘佛於是把我化做一棵树长在你必经的路旁 阳光下慎重地开满了花朵朵都是我前世的盼望 当你走近请你细听那颤抖的叶是我等待的热情 而当你终於无视地走过在你身後落了一地的朋友啊那不是花瓣那是我凋零的心 《一棵开花的树》是中国诗人席慕蓉1980年创作的一首现代诗歌。诗的开篇刻画了主人公曲微深婉的内心，表达出她对爱情的美好期昐；诗的第二节紧承上节诗意，将少女痴痴等待意中人的心境幻化为长在必经之路旁的一棵开花的树；诗的最后一节表达了这位少女一片痴心，空自凋零的失落之情。这首诗富有真情美，娓娓道来却饱含诚挚；极具画面感的意象美；还极具声韵谐和之美，是一首精致感人的美丽小诗。","categories":[{"name":"诗歌与远方","slug":"诗歌与远方","permalink":"https://timbok.github.io/categories/诗歌与远方/"}],"tags":[]},{"title":"nodeJs读书笔记","slug":"nodeJs读书笔记","date":"2019-04-01T06:28:29.000Z","updated":"2020-04-15T12:16:58.180Z","comments":true,"path":"2019/04/01/nodeJs读书笔记/","link":"","permalink":"https://timbok.github.io/2019/04/01/nodeJs读书笔记/","excerpt":"","text":"核心概念 Chrome V8 是 Google 发布的开源 JavaScript 引擎，采用 C/C++ 编写，在 Google 的 Chrome 浏览器中被使用。Chrome V8 引擎可以独立运行，也可以用来嵌入到 C/C++ 应用程序中执行。 Event Loop 事件循环（由 libuv 提供） Thread Pool 线程池（由 libuv 提供） 事件循环和线性池负责所有I/O任务的分发与执行 Node.js在接受任务的时候是单线程的，但在执行具体任务的时候是多线程的。 NodeJS是一个JS脚本解析器，任何操作系统下安装NodeJS本质上做的事情都是把NodeJS执行程序复制到一个目录，然后保证这个目录在系统PATH环境变量下，以便终端下可以使用node命令。 模块系统exports123exports.hello = ()=&gt;&#123; // todo&#125; module 通过module对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。例如模块导出对象默认是一个普通对象，如果想改成一个函数的话，可以使用以下方式。1234567891011//hello.js function Hello() &#123; var name; this.setName = function(thyName) &#123; name = thyName; &#125;; this.sayHello = function() &#123; console.log('Hello ' + name); &#125;; &#125;; module.exports = Hello; 12// other.jsvar hello = require('./hello'); require1var hello = require('./hello'); 文件系统 在fs模块中，所有的方法都分为同步和异步两种实现 API名称有Sync的，皆为同步方法。例: writeFileSync 官方文档 掘金学习文档 文件利用文件读写模仿复制，如下：12345678910111213141516171819const fs = require('fs');function copy(buffer, src) &#123; fs.writeFile(src, buffer, (err)=&gt;&#123; if(!err) &#123; console.log('复制成功'); &#125; &#125;);&#125;function main(src, copyToSrc) &#123; fs.readFile(src, (err, data) =&gt; &#123; if(!err) &#123; copy(data, copyToSrc); &#125; &#125;)&#125;main('../package.json', 'test.txt'); 直接使用fs的复制api，如下：1234567891011function copyFun(src, copyToSrc) &#123; fs.copyFile(src, copyToSrc, err =&gt; &#123; if(err) &#123; console.log(err); &#125; else &#123; console.log('复制成功'); &#125; &#125;);&#125;copyFun('../package.json', 'test.txt'); 文件夹123456789101112131415161718192021222324252627282930// 操作文件夹const fs = require('fs');// 查看文件操作权限function accessFun() &#123; fs.access('../19-03-04', err=&gt;&#123; if(err) &#123; console.log('不可访问'); &#125; else &#123; console.log('可读可写'); &#125; &#125;)&#125;// 读取文件目录下的文件function readdirFun() &#123; fs.readdir('../19-03-04', (err, data) =&gt; &#123; if(!err) &#123; console.log(data); &#125; &#125;);&#125;// 用async将同步方法变成异步async function readdirSyncFun() &#123; const data = await fs.readdirSync('../19-03-04'); console.log(data);&#125;readdirFun(); 进程 process如何玩转子进程 process是一个全局对象，主要有以下属性 stdin 标准输入可读流 stdout 标准输入可写流 stderr 标准错误输出流 argv 终端输入参数数组 env 操作系统环境信息 pid 应用程序进程id 123456789process.stdin.on('data', (chunk) =&gt; &#123; process.stdout.write('接收的数据：' + chunk);&#125;)➜ node process.js➜ 123接收的数据：123➜ data接收的数据：data","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://timbok.github.io/categories/JavaScript/"}],"tags":[]},{"title":"如何给博客加上音乐","slug":"如何给博客加上音乐","date":"2019-03-03T09:23:19.000Z","updated":"2020-04-15T12:16:58.183Z","comments":true,"path":"2019/03/03/如何给博客加上音乐/","link":"","permalink":"https://timbok.github.io/2019/03/03/如何给博客加上音乐/","excerpt":"","text":"介绍今天在逛技术大佬的博客的时候，发现他们的有的生活向的博客放上了自己喜欢的音乐，这让我心神向往。以我的好奇心加爱折腾的个性，必要给我的博客来一个这个功能。😬 正文十多分钟的百度加Google，看到了两种可行的方法。 方法一安装 hexo-tag-aplayer npm install –save hexo-tag-aplayer 在你需要的地方引入1&#123;% aplayer &quot;歌曲名称&quot; &quot;作者&quot; &quot;音乐_url&quot; &quot;封面图片_url&quot; &quot;autoplay&quot; %&#125; 参数列表 title : 曲目标题 author: 曲目作者 url: 音乐文件 URL 地址 picture_url: (可选) 音乐对应的图片地址 narrow: （可选）播放器袖珍风格 autoplay: (可选) 自动播放，移动端浏览器暂时不支持此功能 width:xxx: (可选) 播放器宽度 (默认: 100%) lrc:xxx: （可选）歌词文件 URL 地址 注意：这里的url推荐放在七牛上，加载速度倍快。😀 在该插件的GitHub上还推荐了另一种更便捷的方法。使用MeingJS 以下是GitHub原话 MetingJS 是基于Meting API 的 APlayer 衍生播放器，引入 MetingJS 后，播放器将支持对于 QQ音乐、网易云音乐、虾米、酷狗、百度等平台的音乐播放。 如果想在本插件中使用 MetingJS，请在 Hexo 配置文件 _config.yml 中设置：12aplayer: meting: true 接着就可以通过 在文章中使用 MetingJS 播放器了： 12345&lt;!-- 简单示例 (id, server, type) --&gt;&#123;% meting &quot;60198&quot; &quot;netease&quot; &quot;playlist&quot; %&#125;&lt;!-- 进阶示例 --&gt;&#123;% meting &quot;60198&quot; &quot;netease&quot; &quot;playlist&quot; &quot;autoplay&quot; &quot;mutex:false&quot; &quot;listmaxheight:340px&quot; &quot;preload:none&quot; &quot;theme:#ad7a86&quot;%&#125; 具体请前往 hexo-tag-aplayer 查看 方法二利用网易云提供的音乐iframe标签，在ejs模板里配置。这样的好处就是添加歌曲的位置更自由。 由于网易云有的歌曲没有iframe，博主没有使用该方法 总结想先看加上音乐效果的请查看。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://timbok.github.io/categories/Hexo/"}],"tags":[]},{"title":"周杰伦的歌","slug":"Jay","date":"2019-03-03T08:48:04.000Z","updated":"2020-04-15T12:16:58.177Z","comments":true,"path":"2019/03/03/Jay/","link":"","permalink":"https://timbok.github.io/2019/03/03/Jay/","excerpt":"","text":"网易云没有Jay，但是又不想打开其他音乐播放器。就把周杰伦的歌都放在博客上，想听就来。","categories":[{"name":"诗歌与远方","slug":"诗歌与远方","permalink":"https://timbok.github.io/categories/诗歌与远方/"}],"tags":[]},{"title":"给你的百度画个妆","slug":"百度美化","date":"2019-02-28T12:49:46.000Z","updated":"2020-04-15T12:16:58.184Z","comments":true,"path":"2019/02/28/百度美化/","link":"","permalink":"https://timbok.github.io/2019/02/28/百度美化/","excerpt":"","text":"介绍现在很多网站做的简单便捷，比如掘金（🙈舔狗应有尽有）,但是百度依然是十年前的画风，而且不管你搜索什么都充斥着各种广告，体验极差。今天我们就一起给百度美化一下。😏 Tips: 这其实是个插件推荐博，技术党勿喷。 安装可加载本地CSS的Chrome插件Chrome上此种插件有很多，这里我选择的是Stylish 下载美化规则这个插件的官网有很多大佬写好的美化规则，大家可以自己选择自己喜欢的。 除了百度，你还可以下载腾讯、新浪、谷歌、优酷等美化规则。 在此插件上新建一个CSS样式 如果你不想做伸手党，且你有一点点CSS功底，那么你可以自定义样式。 你想想你女朋友觉得某网页的一个模块很丑，想让它消失。你站起来对她说：无知又愚蠢的女人，让我来帮你搞定吧。🤔 然后你从30块的背包里掏出你的mbp，找到模块的类名，dispaly: none,三步搞定。🤔 最后对女朋友说，你不喜欢的我都让她消失。🤔 可是你没有女朋友。 是你没有女朋友 你没有女朋友。 没有女朋友。 在深色框内你就可以编写自己的样式了。 以下是我编写的百度美化规则，简易的美化了一下百度然后屏蔽了一些广告。喜欢❤可以使用哟。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/* 去除首页广告 */.s-mancacrd-main &#123; display: none;&#125;#s_top_wrap &#123; display: none;&#125;.no-qrcode-layer &#123; display: none;&#125;/* 去除搜索结果广告 */#content_left &gt; .result-op &#123; display: none;&#125;/* 美化搜索结果 */.result &#123; padding: 30px; border-radius: 5px; box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.2);&#125;.result:hover &#123; padding: 30px; border-radius: 5px; box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px 0 rgba(0, 0, 0, 0.14), 0 1px 10px 0 rgba(0, 0, 0, 0.12);&#125;.result &gt; div &#123; margin-top: 10px;&#125;#u &gt; a &#123; text-decoration: none;&#125;.s_form &#123; zoom: 1; height: auto; padding: 5px 0 15px 15px;&#125;#s_tab &#123; background: #f8f8f8; line-height: 36px; height: 38px; padding: 80px 0 0 127px; float: none; zoom: 1;&#125;#content_left &#123; padding-left: 127px;&#125;.s_ipt_wr &#123; height: 40px;&#125;.s_btn &#123; height: 42px&#125;.s_ipt &#123; margin: 9px 0 0 7px;&#125;#result_logo &#123; margin: 9px 0 0;&#125;.ipt_rec:after &#123; display: none;&#125;.ipt_rec &#123; width: 0px; height: 0px;&#125;.nums &#123; margin: 0px 0 0 127px; height: 42px; line-height: 42px;&#125;#content_right &#123; margin-top: 80px;&#125;.cr-title-sub &#123; text-decoration: none;&#125;#head .bdsug &#123; top: 42px;&#125;/* 搜索框 */.bdsug li &#123; padding: 5px;&#125;.bdsug li:hover &#123; padding: 8px;&#125; 效果对比： 总结好了。又水了一篇文章。🚣 喜欢请点赞。彳亍口巴？","categories":[{"name":"工具资源","slug":"工具资源","permalink":"https://timbok.github.io/categories/工具资源/"}],"tags":[]},{"title":"JavaScript闯关笔记","slug":"JavaScript闯关笔记","date":"2019-02-23T01:20:27.000Z","updated":"2020-05-08T03:06:27.166Z","comments":true,"path":"2019/02/23/JavaScript闯关笔记/","link":"","permalink":"https://timbok.github.io/2019/02/23/JavaScript闯关笔记/","excerpt":"","text":"介绍通过Array/Object/Function/Api基础类型编写。 看到自己不了解的或者比较新颖的用法便会写上。 不定时更新内容。 本文首发于我的个人网站: Timbok.top 目录 Array 迭代方法 split和join splice from Object object映射 Function promise async-await 获取函数参数名 Api 可选链 逗号表达式 原型和原型链 Array迭代方法 every()方法对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true 12345const arr = [1,2,3,4];const result = arr.every((item, index, arr)=&gt;&#123; return item &gt; 2;&#125;);console.log(result); // false some()方法 对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true 12345const arr = [1, 2, 3, 4];const result = arr.some((item, index, arr)=&gt;&#123; return item &gt; 2;&#125;);console.log(result); // true filter()方法对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组 12345const arr = [1, 2, 3, 4];const result = arr.filter((item, index)=&gt;&#123; return item &gt; 2;&#125;);console.log(result); // [3, 4] map()方法 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组 12345const arr = [1, 2, 3, 4];const result = arr.map((item, index)=&gt;&#123; return item * index;&#125;);console.log(result); // [0, 2, 6, 12] forEach()方法 对数组中的每一项运行给定函数。这个方法没有返回值，本质上与使用 for 循环迭代数组一样 1234const arr = [1, 2, 3, 4];const result = arr.forEach((item, index)=&gt;&#123; // 执行某些操作&#125;); reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。对空数组是不会执行回调函数的。 arr.reduce(callback,[initialValue]) callback （执行数组中每个值的函数，包含四个参数） previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue）） currentValue （数组中当前被处理的元素） index （当前元素在数组中的索引） array （调用 reduce 的数组） initialValue （作为第一次调用 callback 的第一个参数。） 无返回值12345const arr = [1, 2, 3];arr.reduce((pev, item)=&gt;&#123; console.log(pev, item);&#125;, 0);// 运行结果依次为：0 1; undefined 2; undefined 3; 有返回值12345678// pev为上次迭代return的值const arr = [1, 2, 3, 4];const result = arr.reduce((pev, item)=&gt;&#123; console.log(pev); return pev + item;&#125;, 0);console.log(result); // 10// pev运行结果依次为：0, 1, 3, 6 split和joinsplit(): 用于把一个字符串分割成字符串数组。12const string = '1, 2, 3, 4, 5';string.split(','); // [\"1\", \"2\", \"3\", \"4\", \"5\"] 如果string为空，则返回一个空数组123const string = '';string.split(','); // [\"\"]string.split(); // [\"\"] join(): 用于把数组中的所有元素放入一个字符串。123const array = [1, 2, 3, 4, 5];array.join(); // '1,2,3,4,5' 默认用，分割array.join('|'); // \"1|2|3|4|5\" 默认用，分割 splicesplice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。 注释：该方法会改变原始数组。 arrayObject.splice(index,howmany,item1,.....,itemX) 参数 描述 index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。 howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。 item1, …, itemX 可选。向数组添加的新项目。 举个例子🌰12345678var arr = [];//增加arr.splice(0, 1, 1); // arr = [1]arr.splice(1, 1, 2); // arr = [1, 2]arr.splice(2, 1, 3); // arr = [1, 2, 3]// 删除arr.splice(2, 1); // arr = [1, 2] fromMDN释义：Array.from() 方法从一个类似数组或可迭代对象中创建一个新的 用法： 将字符串拆成数组 12Array.from('foo'); // [\"f\", \"o\", \"o\"] 将类数组转换为数组 123456789let array = &#123; 0: 'name', 1: 'age', 2: 'sex', 3: ['user1','user2','user3'], 'length': 4&#125;let arr = Array.from(array )console.log(arr) // ['name','age','sex',['user1','user2','user3']] 用length生成数组 12Array.from(&#123; length: 4 &#125;, (...arg) =&gt; arg[1])// [0, 1, 2, 3] Objectobject映射定义一个object作为配置对象来存放不同状态，通过链表查找 123456789101112const statusMap = &#123; 1:()=&gt;&#123; console.log('a1') &#125;, 2:()=&gt;&#123; console.log('b2') &#125; /* n.... */&#125;// 执行let a = 1 statusMap[a]() // a1 这样比较清晰，将条件配置与具体执行分离。如果要增加其他状态，只修改配置对象即可。 FunctionpromiseECMAscript 6 原生提供了 Promise 对象。 Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息。 Promise 对象有以下两个特点: 1、对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态： pending: 初始状态，不是成功或失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。 2、一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 简单实现：12345678function _promise(params) &#123; return new Promise((resolve, reject)=&gt;&#123; params&gt;0 ? resolve('正数') : reject('负数'); &#125;);&#125;_promise(1).then(res=&gt;console.log(res)) // 正数_promise(-1).catch(res=&gt;console.log(res)) // 负数 Promise.allPromise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。 123456789101112131415161718192021let p1 = new Promise((resolve, reject) =&gt; &#123; resolve('成功了')&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; resolve('success')&#125;)let p3 = Promise.reject('失败')Promise.all([p1, p2]).then((result) =&gt; &#123; console.log(result) //['成功了', 'success']&#125;).catch((error) =&gt; &#123; console.log(error)&#125;)Promise.all([p1,p3,p2]).then((result) =&gt; &#123; console.log(result)&#125;).catch((error) =&gt; &#123; console.log(error) // '失败'&#125;) 需要特别注意的是，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，即p1的结果在前，即便p1的结果获取的比p2要晚。这带来了一个绝大的好处：在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景，使用Promise.all毫无疑问可以解决这个问题。 Promise.race顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。 1234567891011121314151617let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('success') &#125;,1000)&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject('failed') &#125;, 500)&#125;)Promise.race([p1, p2]).then((result) =&gt; &#123; console.log(result)&#125;).catch((error) =&gt; &#123; console.log(error) // 打开的是 'failed'&#125;) async-awaitES2017 标准引入了async 函数，使得异步操作变得更加方便。 async 函数是什么？一句话，它其实就是promise 和Generator 函数的语法糖。 asyncasync 用来表示函数是异步的，定义的函数会返回一个promise对象，可以使用then方法添加回调函数。 12345678async function test() &#123; return 123;&#125;test().then(res =&gt; &#123; console.log(res);// 123&#125;);若 async 定义的函数有返回值，return 123;相当于Promise.resolve(123),没有声明式的 return则相当于执行了Promise.resolve(); awaitawait 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。 1234function notAsyncFunc() &#123; await Math.random();&#125;notAsyncFunc();//Uncaught SyntaxError: Unexpected identifier await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行。 1234567891011121314151617181920function sleep(second) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(' enough sleep~'); &#125;, second); &#125;)&#125;function normalFunc() &#123; console.log('normalFunc');&#125;async function awaitDemo() &#123; await normalFunc(); console.log('something, ~~'); let result = await sleep(2000); console.log(result);// 两秒之后会被打印出来&#125;awaitDemo();// normalFunc// VM4036:13 something, ~~// VM4036:15 enough sleep~ 希望通过上面的 demo，大家可以理解我上面的话。 错误处理上述的代码好像给的都是resolve的情况，那么reject的时候我们该如何处理呢？ 1234567891011121314151617181920212223242526function sleep(second) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject('want to sleep~'); &#125;, second); &#125;)&#125;async function errorDemo() &#123; let result = await sleep(1000); console.log(result);&#125;errorDemo();// VM706:11 Uncaught (in promise) want to sleep~// 为了处理Promise.reject 的情况我们应该将代码块用 try catch 包裹一下async function errorDemoSuper() &#123; try &#123; let result = await sleep(1000); console.log(result); &#125; catch (err) &#123; console.log(err); &#125;&#125;errorDemoSuper();// want to sleep~// 有了 try catch 之后我们就能够拿到 Promise.reject 回来的数据了。 最后一点，await必须在async函数的上下文中的。 参考文章 获取函数参数名12345678910111213function getParameterName(fn) &#123; if(typeof fn !== 'object' &amp;&amp; typeof fn !== 'function' ) return; const COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg; const DEFAULT_PARAMS = /=[^,)]+/mg; const FAT_ARROWS = /=&gt;.*$/mg; let code = fn.prototype ? fn.prototype.constructor.toString() : fn.toString(); code = code .replace(COMMENTS, '') .replace(FAT_ARROWS, '') .replace(DEFAULT_PARAMS, ''); let result = code.slice(code.indexOf('(') + 1, code.indexOf(')')).match(/([^\\s,]+)/g); return result === null ? [] :result;&#125; 示例 123function example(x, y) &#123; return x, y &#125;;getParameterName(example); // [\"x\", \"y\"] Api可选链?.MDN释义 可选链操作符?.能够去读取一个被连接对象的深层次的属性的值而无需明确校验链条上每一个引用的有效性 基本使用123let prop = obj?.prop// 等同于let prop = obj &amp;&amp; obj.prop 可选链与函数调用 函数调用时如果被调用的方法不存在，使用可选链可以使表达式自动返回undefined而不是抛出一个异常。1props.onSearch?.() 注意：可选链在赋值时无效12let object = &#123;&#125;;object?.property = 1; // Uncaught SyntaxError: Invalid left-hand side in assignment 逗号表达式MDN释义：对它的每个操作数求值（从左到右），并返回最后一个操作数的值。 例12345678910var a = (1, 2, 3);console.log(a); // 3// ...function num() &#123; var a, b, c = 1, 2, 3; return a, b, c;&#125;num() // 3 原型和原型链原型在 JavaScript 中，函数（function）是允许拥有属性的。所有的函数会有一个特别的属性 —— prototype，这个属性就是原型，它是一个对象。 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中 1234567891011function Person(name, age) &#123; this.name = name; this.age = age; this.sayName = function() &#123; return this.name; &#125;&#125;var timbok = new Person('timbok', 18);var lucy = new Person('lucy', 20);console.log(timbok.sayName === lucy.sayName); // false 可以看到，对于同一个函数，我们通过 new 生成出来的实例，都会开出新的一块堆区，所以上面代码中 timbok 和 lucy的sayName不相等。 当使用prototype时 1234567Person.prototype.eat = function() &#123; console.log('吃');&#125;var timbok = new Person('timbok', 18);var lucy = new Person('lucy', 20);console.log(timbok.eat === lucy.eat); // true 原型链在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。 123Person.prototype.constructor === Person // truePerson.prototype === timbok.__proto__ // true 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined。 123456Person.prototype.a = 123;var person = new Person()console.log(person.a) // 123console.log(person.b) // undefined person.a: 先在person对象里找a -&gt; 没找到会再到person.__proto__，也就是 Person.prototype内找 -&gt; 找到了 person.b: 先在person对象里找b -&gt; 没找到会再到person.__proto__内找 -&gt; 查找与对象关联的原型中的属性 -&gt; 找原型的原型，一直找到最顶层Object为止 -&gt; 找不到就undefined 衍生扩展-new操作符要想弄懂new，得先了解一下何为构造函数？ 构造函数构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数 用以下的例子来模仿 var person = new Person() 的过程 12345678910111213141516171819202122// 1. 需要一个创造器function Creator() &#123; this.name='creator' console.log(\"创造器\");&#125;// 2. 新建变量，开辟内存var person = &#123;&#125;;// 3. 通过 __proto__ 指向Creator的原型person.__proto__ = Creator.prototype// 4. call person 使其可以扩展nameCreator.call(person) // 创造器// 5.在原型上增加方法Creator.prototype.action = function() &#123; console.log('创造动作')&#125;person.action() // 创造动作console.log(person) // Creator &#123;name: 1&#125; 关于 this、apply、call、bind 可以看这篇文章。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://timbok.github.io/categories/JavaScript/"}],"tags":[]},{"title":"MacBook常用快捷键","slug":"MacBook快捷键","date":"2019-02-18T12:31:13.000Z","updated":"2020-04-15T12:16:58.178Z","comments":true,"path":"2019/02/18/MacBook快捷键/","link":"","permalink":"https://timbok.github.io/2019/02/18/MacBook快捷键/","excerpt":"","text":"Mac常用快捷键Finder 快捷键 作用 备注 Shift + Command + G 前往指定路径的文件夹 包括隐藏文件夹 Shift + Command + . 显示隐藏文件、文件夹 再按一次，恢复隐藏 Command + ↑ 返回上一层 Command + ↓ 进入当前文件夹 编辑删除文字： 快捷键 作用 备注 delete 删除光标的前一个字符 相当于 Windows 键盘上的退格键 fn + delete 删除光标的后一个字符 option + delete 删除光标之前的一个单词 英文有效 command + delete 删除光标之前的整行内容 【荐】 command + delete 在finder中删掉该文件 shift + command + delete 清空回收站 剪切文件： 首先选中文件，按Command+C复制文件；然后按「Command＋Option＋V」剪切文件。 备注：Command+X只能剪切文字文本，不要混淆了。 Mac用户必须知道的15组快捷键 参考链接：《轻松玩Mac》第6期：Mac用户必须知道的15组快捷键 「space」键：快速预览选中文件后， 不需要启动任何应用程序，使用「space」空格键可进行快速预览，再次按下「space」空格键取消预览。 可以预览mp3、视频、pdf等文件。 我们还可以选中多张图片， 然后按「space」键，就可以同时对比预览多张图片。这一点，很赞。 改名选中文件/文件夹后，按enter键，就可以改名了。 「command + I」键：查看文件属性 选中文件后，按「command + I」键，可以查看文件的各种属性。 选中文件夹后，按「command + I」键，可以查看文件夹的大小。【荐】 切换输入法「control + space」 打开 spotlight 搜索框spotlight是系统自带的软件，搜索功能不是很强大。我们一般都会用第三方的 Alfred 软件。 编辑相关Cmd+C、Cmd+V、Cmd+X、Cmd+A、Cmd+Z。 翻页和光标 「control + ↑」：将光标定位到文章的最开头（翻页到文档的最上方） 「control + ↓」：将光标定位到文章的最末尾（翻页到文档的最下方） 「control + ←」：将光标定位到当前行的最左侧 「control + →」：将光标定位到当前行的最右侧 「command + shift + Y」：将文字快速保存到便笺选中你想要的内容（例如文字、链接等），然后按下command + shift + Y」，那么你选中的内容就会快速保存到系统自带的「便笺」软件中。 如果你想临时性的保存一段内容，这个操作很实用。 程序相关 「command + Q」：快速退出程序 「command + tab」：切换程序 「command + H」：隐藏当前应用程序。这是一个有趣的快捷键。 「command + ，」：打开当前应用程序的「偏好设置」。 窗口相关 「command + N」：新建一个当前应用程序的窗口 「command + `」：在当前应用程序的不同窗口之间切换【很实用】 我们知道，「command + tab」是在不同的软件之间切换。但你不知道的是，「command + `」是在同一个软件的不同窗口之间切换。 「command + M」：将当前窗口最小化 「command + W」：关闭当前窗口 浏览器相关 「command + T」：浏览器中，新建一个标签 「command + W」：关闭当前标签 「command + R」：强制刷新。 「command + L」：定位到地址栏。【重要】 截图相关 「command + shift + 3」：截全屏（对整个屏幕截图）。 声音相关选中文字后，按住「ctrl + esc」键，会将文字进行朗读。（我发现，在触控条版的mac上，并没有生效） Dock栏相关 「option + command + D」：隐藏dock栏 强制推出 强制退出的快捷键非常重要 「option + command + esc」：打开强制退出的窗口 option相关 强烈推荐 「option + command + H」：隐藏除当前应用程序之外的其他应用程序 在文本中，按住「option」键，配合鼠标的选中，可以进行块状文字选取。 「option + command + W」：快速关闭当前应用程序的所有窗口。【很实用】 比如说，你一次性打开了很多文件的详情，然后就可以通过此快捷键，将这些窗口一次性关闭。 「option + command + I」：查看多个文件的总的属性。 打开launchpad，按住「option」键，可以快速卸载应用程序。 在dock栏，右键点击软件图标，同时按住「option」键，就可以强制退出该软件。【重要】 在Safari浏览器中，按住「option + command + Q」退出Safari。等下次进入Safari的时候，上次退出时的网址会自动被打开。【实用】 推荐一个软件：CheatSheet打开CheatSheet后，长按 command 键，会弹出当前应用程序的所有快捷键。我们还可以对这些快捷键进行保存。","categories":[{"name":"工具资源","slug":"工具资源","permalink":"https://timbok.github.io/categories/工具资源/"}],"tags":[]},{"title":"TYPESCRIPT指南（译文）","slug":"TypeScript","date":"2019-01-30T02:39:41.000Z","updated":"2020-04-15T12:16:58.180Z","comments":true,"path":"2019/01/30/TypeScript/","link":"","permalink":"https://timbok.github.io/2019/01/30/TypeScript/","excerpt":"","text":"前言 原文地址：https://flaviocopes.com/typescript/ 原文作者：Flavio 译者：Timbok 翻译工具：Google Translate 正文什么？都2019了，你还不会TypeScirpt？别担心，我也不会，前几天看到一篇写的很好的入门文章，翻译一下，一起学习。 TypeScript是2018年发展最快的技术之一。它无处不在，每个人都在谈论它。本文将指导您了解其关键概念 过去几年中，很少有技术能有TypeScript这么大的影响。让我添加一些证据，支持TypeScript。 在“The State of JavaScript 2018”调查中，近50％的受访者表示他们使用TypeScript，并会再次使用它。超过30％的人表示他们想学习它。对此感兴趣的人中有很大一部分。 TypeScript是由微软创建的，它对于创建编程语言并不陌生，其创建者之一是Anders Hejlsberg，一位以Turbo Pascal（❤️）和Delphi而闻名的丹麦软件工程师。我把心思放在Turbo Pascal上，因为Pascal是我的第一个编程语言，我们在学校使用了Turbo Pascal。 它是一种开源语言，在https://github.com/Microsoft/TypeScript上公开开发。 Angular是使用TypeScript的，据说Vue.js使用TypeScript制作3.0版本。Node.js的创建者Ryan Dahl也说了很多关于它的事情。 我认为这些东西有助于你清晰认识TypeScript。这不仅仅是一种随机的JavaScript风格，将在下个月消亡，它绝对会留下来。事实上，这意味着您可能需要在未来的项目或下一个工作中使用它。也许它会帮助你找到一份工作，所以让我们深入研究它。 编写并编译您的第一个TYPESCRIPT文件TypeScript开始很容易。如果您曾经写过一行JavaScript，那么您已经编写了TypeScript代码！ 我所做的这个奇怪的陈述是TypeScript成功的原因之一：它是JavaScript的严格超集。 这有点像SCSS的CSS。 特别是，它是ECMAScript 2015（也称为ES6）的超集。这意味着任何有效的JavaScript也是有效的TypeScript。 TypeScript的许多功能都等同于JavaScript。例如变量，模块系统，迭代器等。 所以，没有必要编写绝对的第一个TypeScript文件，因为你已经在你不知道的情况下写过，让我们通过显式制作一个TypeScript文件来制作一个“hello world！”，并将其编译成JavaScript。 运行npm install -g typescript以全局安装可使用tsc命令使用的TypeScript编译器。 创建一个新文件夹，然后创建一个app.ts文件。.ts是TypeScript文件扩展名。 写下第一个程序：12345const greet = () =&gt; &#123; console.log('Hello world!')&#125;greet() 这只是普通的JavaScript，但存储在一个.ts文件中。 现在使用编译程序tsc app.ts。结果将是一个新的JavaScript文件：app.js，包含以下内容：1234var greet = function () &#123; console.log('Hello world!');&#125;;greet(); TypeScript代码已编译为JavaScript。JavaScript代码稍有改动，例如你可以注意到它添加了分号，var用来代替const和使用常规函数而不是箭头函数。 它看起来像旧的 JavaScript，对吗？这是因为TypeScript默认编译为ES5，因为这是几乎可以保证在所有现代浏览器中都支持的ECMAScript版本。您可以将编译目标更改为其他版本，例如编译为ES2018：tsc app.ts --target ES2018： 1234const greet = () =&gt; &#123; console.log('Hello world!');&#125;;greet(); 看，这里几乎没有改变我们的原始.ts文件，除了额外的分号。 有一个非常方便的网站，可让您在https://www.typescriptlang.org/play/上使用TypeScript到JavaScript编辑。 类型到目前为止，我们编译了一个.ts文件，但我们只编译了纯JavaScript。 您看到了TypeScript的第一个功能：您可以使用现代JavaScript并将其编译为ES5（或更高版本），这是Babel所做的。我们还没有使用任何TypeScript功能。 TypeScript提供的最重要的功能是类型系统：静态类型，接口，类型推断，枚举，混合类型，泛型，联合/交集类型，访问修饰符，空检查。 如果你曾经使用过类型语言，比如Go或C，你已经知道它是如何工作的。如果没有，并且您只使用Python或Ruby这样的动态语言进行编程，这对您来说是全新的，但不要担心。 例如，类型系统允许您向变量，函数参数和函数返回类型添加类型，从而为程序提供更严格的结构。我们编译的JavaScript代码没有类型，它们在编译阶段会丢失。 以下是在TypeScript中定义字符串变量的方法：1const greeting : string = \"hello!\" 类型推断让我们避免在明显的情况下编写类型：1const greeting = \"hello!\" 类型由TS确定。 这是函数接受特定类型的参数的方式：123const multiply = (a: number, b: number) =&gt; &#123; return a * b&#125; 如果传递一个字符串给multiply()，编译器会给你一个错误。 以下是函数声明其返回值的方式：123const multiply = (a: number, b: number): number =&gt; &#123; return a * b&#125; 有效类型是 number string boolean enum void null undefined any never Array tuple any 是一种全能类型，如其名称所示，可识别任何类型。 类ES2015 / ES6为JavaScript 添加了类，作为原型继承的简单语法糖。 无论喜欢与否，在引擎盖下，JavaScript仍然使用原型继承，具有其独特的功能和怪癖。 TypeScript类与JavaScript类略有不同。原因是TypeScript在JavaScript之前引入了类（它们是在ES2015 / ES6中引入的）。 就像在JavaScript中一样，您以这种方式声明类：123class Car &#123;&#125; 默认情况下，所有字段都是公开 您可以将字段设置为私有或受保护：12345class Car &#123; public color: string private name: string protected brand: string&#125; 就像在其他编程语言中发生的那样，私有字段只能在声明它们的类中访问。受保护的字段也只能通过派生类来访问。 您还可以声明静态字段，它们是类字段而不是对象字段：123class Car &#123; static numberOfWheels = 4&#125; 您可以使用构造函数初始化字段：123456class Car &#123; color: string constructor(theColor: string) &#123; this.color = theColor &#125;&#125; 这种简写语法使其更简单：123456789class Car &#123; constructor(public color: string) &#123;&#125; printColor() &#123; alert(this.color) &#125;&#125;(new Car('red')).printColor() 字段也可以是只读的：123class Car &#123; readonly color: string&#125; 在这种情况下，它的值只能在构造函数中设置。 类具有方法：123456789class Car &#123; color: string constructor(public color: string) &#123; this.color = color &#125; drive() &#123; console.log('You are driving the car') &#125;&#125; 与纯JavaScript一样，您可以使用new关键字从这些类创建对象：1const myCar = new Car('red') 并且您可以使用extend关键字扩展现有类：123class ElectricCar extends Car &#123; //...&#125; 您可以在构造函数和方法中调用super()来调用扩展类对应的方法 类可以定义为抽象，这意味着需要有一个扩展它的类，并实现其最终的抽象方法：123456789abstract class Car &#123; abstract drive()&#125;class SportsCar extends Car &#123; drive() &#123; console.log('You are driving a sports car') &#125;&#125; 访问器字段可以有getter和setter。例：1234567891011class Car &#123; private _color: string get color(): string &#123; return this._color &#125; set color(color: string) &#123; this._color = color &#125;&#125; 接口接口基于基本类型构建。您可以将接口用作类型，并且此接口可以包含其他类型定义：12345678910interface SetOfNumbers &#123; a: number; b: number;&#125;const multiply = (set: SetOfNumbers) =&gt; &#123; return set.a * set.b&#125;multiply(&#123; a:1, b: 2 &#125;) 接口也可以是类实现的接口：123456789101112131415interface Car &#123; name: 'string' new (brand: string) drive(): void&#125;class SportsCar implements Car &#123; public name construtor(public brand: string) &#123; //... &#125; drive() &#123; console.log('You are driving a sports car') &#125;&#125; 函数特点函数可以使用?来表明参数类型可选：123456789class Car &#123; drive(kilometers?: number) &#123; if (kilometers) &#123; console.log(`Drive the car for $&#123;kilometers&#125; kilometers`) &#125; else &#123; console.log(`Drive the car`) &#125; &#125;&#125; 参数也可以有默认值：12345class Car &#123; drive(kilometers = 10) &#123; console.log(`Drive the car for $&#123;kilometers&#125; kilometers`) &#125;&#125; 函数可以使用...接受不同数量的参数：1234567class Car &#123; drive(kilometers = 10, ...occupants: string[]) &#123; console.log(`Drive the car for $&#123;kilometers&#125; kilometers, with those people on it:`) occupants.map((person) =&gt; console.log(person)) &#125;&#125;(new Car()).drive(20, 'Flavio', 'Roger', 'Syd') 枚举枚举是定义命名常量的一种很好的方法，遗憾的是，它不受JavaScript支持，但是被其他语言推广。 TypeScript为我们提供了枚举：123456enum Order &#123; First, Second, Third, Fourth&#125; TS在内部为每个值分配唯一标识符，我们可以简单地引用Order.First，Order.Second依此类推。 您可以显式地为常量指定值：123456enum Order &#123; First = 0, Second = 1, Third = 2, Fourth = 3&#125; 或者也使用字符串：123456enum Order &#123; First = 'FIRST', Second = 'SECOND', Third = 'THIRD', Fourth = 'FOURTH'&#125; 泛型泛型是许多不同编程语言的一部分。简而言之，您可以创建一个使用不同类型的函数，接口或类，而无需预先指定类型。 但是在编译时，如果你开始使用一个类型的函数，然后你改变类型（例如从数字到字符串），编译器将抛出一个错误。 我们可以通过省略类型或使用any类型来实现这一点，但是使用泛型，所有工具都能够帮助我们 示例语法：1234function greet&lt;T&gt;(a : T) &#123; console.log(`Hi $&#123;a&#125;!`)&#125;greet('Flavio') 有趣的T符号标识通用类型。 可以使用以下extends关键字将类型限制为某个类或接口：12345interface Greetable &#123; name: string &#125;function greet&lt;T extends Greetable&gt;(a : T) &#123; alert(`Hi $&#123;a.name&#125;!`)&#125;greet(&#123; name: 'Flavio'&#125;) 总结这些都是TypeScript的基础知识。详细学习地址： 中文文档：https://github.com/zhongsp/TypeScript 英文文档：http://www.typescriptlang.org/docs/home.html 能力有限，水平一般，翻译不妥之处，还望指正。感谢。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://timbok.github.io/categories/JavaScript/"}],"tags":[]},{"title":"每个JavaScript开发人员都应该知道的新ES2018功能（译文）","slug":"ES2018","date":"2019-01-13T07:40:24.000Z","updated":"2020-04-15T12:16:58.175Z","comments":true,"path":"2019/01/13/ES2018/","link":"","permalink":"https://timbok.github.io/2019/01/13/ES2018/","excerpt":"","text":"前言 原文地址：https://css-tricks.com/new-es2018-features-every-javascript-developer-should-know/ 原文作者：Faraz Kelhini 译者：Timbok 翻译工具：Google Translate 正文ECMAScript标准的第九版，官方称为ECMAScript 2018（或简称ES2018），于2018年6月发布。从ES2016开始，ECMAScript规范的新版本每年发布而不是每几年发布一次，并且添加的功能少于主要版本以前。该标准的最新版本通过添加四个新RegExp功能，rest/spread属性，asynchronous iteration，和Promise.prototype.finally。此外，ES2018从标记模板中删除了转义序列的语法限制。 这些新变化将在后面的小节中解释。 rest/spread属性ES2015最有趣的功能之一是点差运算符。该运算符使复制和合并数组变得更加简单。您可以使用运算符...，而不是调用concat()or slice()方法： 12345678910111213const arr1 = [10, 20, 30];// make a copy of arr1const copy = [...arr1];console.log(copy); // → [10, 20, 30]const arr2 = [40, 50];// merge arr2 with arr1const merge = [...arr1, ...arr2];console.log(merge); // → [10, 20, 30, 40, 50] 在必须作为函数的单独参数传入数组的情况下，扩展运算符也派上用场。例如： 12345const arr = [10, 20, 30]// equivalent to// console.log(Math.max(10, 20, 30));console.log(Math.max(...arr)); // → 30 ES2018通过向对象文字添加扩展属性来进一步扩展此语法。使用spread属性，您可以将对象的自身可枚举属性复制到新对象上。请考虑以下示例： 1234567891011const obj1 = &#123; a: 10, b: 20&#125;;const obj2 = &#123; ...obj1, c: 30&#125;;console.log(obj2); // → &#123;a: 10, b: 20, c: 30&#125; 在此代码中，...运算符用于检索属性obj1并将其分配给obj2。在ES2018之前，尝试这样做会引发错误。如果有多个具有相同名称的属性，则将使用最后一个属性： 1234567891011const obj1 = &#123; a: 10, b: 20&#125;;const obj2 = &#123; ...obj1, a: 30&#125;;console.log(obj2); // → &#123;a: 30, b: 20&#125; Spread属性还提供了一种合并两个或多个对象的新方法，可以将其用作方法的替代Object.assign()方法： 123456789const obj1 = &#123;a: 10&#125;;const obj2 = &#123;b: 20&#125;;const obj3 = &#123;c: 30&#125;;// ES2018console.log(&#123;...obj1, ...obj2, ...obj3&#125;); // → &#123;a: 10, b: 20, c: 30&#125;// ES2015console.log(Object.assign(&#123;&#125;, obj1, obj2, obj3)); // → &#123;a: 10, b: 20, c: 30&#125; 但请注意，spread属性并不总是产生相同的结果Object.assign()。请考虑以下代码： 1234567891011121314Object.defineProperty(Object.prototype, 'a', &#123; set(value) &#123; console.log('set called!'); &#125;&#125;);const obj = &#123;a: 10&#125;;console.log(&#123;...obj&#125;); // → &#123;a: 10&#125;console.log(Object.assign(&#123;&#125;, obj)); // → set called!// → &#123;&#125; 在此代码中，该Object.assign()方法执行继承的setter属性。相反，传播属性完全忽略了setter。 重要的是要记住，spread属性只复制可枚举的属性。在以下示例中，type属性不会显示在复制的对象中，因为其enumerable属性设置为false： 12345678910const car = &#123; color: 'blue'&#125;;Object.defineProperty(car, 'type', &#123; value: 'coupe', enumerable: false&#125;);console.log(&#123;...car&#125;); // → &#123;color: \"blue\"&#125; 即使它们是可枚举的，也会忽略继承的属性： 123456789101112131415161718const car = &#123; color: 'blue'&#125;;const car2 = Object.create(car, &#123; type: &#123; value: 'coupe', enumerable: true, &#125;&#125;);console.log(car2.color); // → blueconsole.log(car2.hasOwnProperty('color')); // → falseconsole.log(car2.type); // → coupeconsole.log(car2.hasOwnProperty('type')); // → trueconsole.log(&#123;...car2&#125;); // → &#123;type: \"coupe\"&#125; 在此代码中，car2继承color属性car。因为spread属性只复制对象的自己的属性，color所以不包含在返回值中。 请记住，spread属性只能生成对象的浅表副本。如果属性包含对象，则仅复制对象的引用： 12345const obj = &#123;x: &#123;y: 10&#125;&#125;;const copy1 = &#123;...obj&#125;; const copy2 = &#123;...obj&#125;; console.log(copy1.x === copy2.x); // → true 这里copy1和copy2的x是指在内存中的同一对象，所以全等运算返回true。 ES2015中添加的另一个有用功能是rest参数，它使JavaScript程序员可以使用它...来表示值作为数组。例如： 12345const arr = [10, 20, 30];const [x, ...rest] = arr;console.log(x); // → 10console.log(rest); // → [20, 30] 这里，arr的第一个值被分配给对应的x，而剩余的元素被分配给rest变量。这种称为阵列解构的模式变得如此受欢迎，以至于Ecma技术委员会决定为对象带来类似的功能： 12345678910const obj = &#123; a: 10, b: 20, c: 30&#125;;const &#123;a, ...rest&#125; = obj;console.log(a); // → 10console.log(rest); // → &#123;b: 20, c: 30&#125; 此代码使用解构赋值中的其余属性将剩余的自身可枚举属性复制到新对象中。请注意，rest属性必须始终出现在对象的末尾，否则会引发错误： 1234567const obj = &#123; a: 10, b: 20, c: 30&#125;;const &#123;...rest, a&#125; = obj; // → SyntaxError: Rest element must be last element 还要记住，在对象中使用多个rest会导致错误，除非它们是嵌套的： 123456789101112const obj = &#123; a: 10, b: &#123; x: 20, y: 30, z: 40 &#125;&#125;;const &#123;b: &#123;x, ...rest1&#125;, ...rest2&#125; = obj; // no errorconst &#123;...rest, ...rest2&#125; = obj; // → SyntaxError: Rest element must be last element Support for Rest/Spread Chrome Firefox Safari Edge 60 55 11.1 No Chrome Android Firefox Android iOS Safari Edge Mobile Samsung Internet Android Webview 60 55 11.3 No 8.2 60 Node.js 8.0.0（运行时需要加-harmony） 8.3.0（完全支持） Asynchronous Iteration(异步迭代)迭代数据集是编程的重要部分。此前ES2015，提供的JavaScript语句如for，for...in和while，和方法map()，filter()以及forEach()都用于此目的。为了使程序员能够一次一个地处理集合中的元素，ES2015引入了迭代器接口。 如果对象具有Symbol.iterator属性，则该对象是可迭代的。在ES2015中，字符串和集合对象（如Set，Map和Array）带有Symbol.iterator属性，因此可以迭代。以下代码给出了如何一次访问可迭代元素的示例： 1234567const arr = [10, 20, 30];const iterator = arr[Symbol.iterator](); console.log(iterator.next()); // → &#123;value: 10, done: false&#125;console.log(iterator.next()); // → &#123;value: 20, done: false&#125;console.log(iterator.next()); // → &#123;value: 30, done: false&#125;console.log(iterator.next()); // → &#123;value: undefined, done: true&#125; Symbol.iterator是一个众所周知的符号，指定一个返回迭代器的函数。与迭代器交互的主要方法是next()方法。此方法返回具有两个属性的对象：value和done。value属性为集合中下一个元素的值。done属性的值为true或false表示集合是否迭代完成。 默认情况下，普通对象不可迭代，但如果在其上定义Symbol.iterator属性，则它可以变为可迭代，如下例所示： 123456789101112131415161718192021222324const collection = &#123; a: 10, b: 20, c: 30, [Symbol.iterator]() &#123; const values = Object.keys(this); let i = 0; return &#123; next: () =&gt; &#123; return &#123; value: this[values[i++]], done: i &gt; values.length &#125; &#125; &#125;; &#125;&#125;;const iterator = collection[Symbol.iterator](); console.log(iterator.next()); // → &#123;value: 10, done: false&#125;console.log(iterator.next()); // → &#123;value: 20, done: false&#125;console.log(iterator.next()); // → &#123;value: 30, done: false&#125;console.log(iterator.next()); // → &#123;value: undefined, done: true&#125; 此对象是可迭代的，因为它定义了一个Symbol.iterator属性。迭代器使用该Object.keys()方法获取对象属性名称的数组，然后将其分配给values常量。它还定义了一个计数器变量i，并给它一个初始值0.当执行迭代器时，它返回一个包含next()方法的对象。每次调用next()方法时，它都返回一对{value, done}，value保持集合中的下一个元素并done保持一个布尔值，指示迭代器是否已达到集合的需要。 虽然这段代码完美无缺，但却不必要。使用生成器函数可以大大简化过程： 1234567891011121314151617const collection = &#123; a: 10, b: 20, c: 30, [Symbol.iterator]: function * () &#123; for (let key in this) &#123; yield this[key]; &#125; &#125;&#125;;const iterator = collection[Symbol.iterator](); console.log(iterator.next()); // → &#123;value: 10, done: false&#125;console.log(iterator.next()); // → &#123;value: 20, done: false&#125;console.log(iterator.next()); // → &#123;value: 30, done: false&#125;console.log(iterator.next()); // → &#123;value: undefined, done: true&#125; 在这个生成器中，for...in循环用于枚举集合并产生每个属性的值。结果与前一个示例完全相同，但它大大缩短了。 迭代器的缺点是它们不适合表示异步数据源。ES2018的补救解决方案是异步迭代器和异步迭代。异步迭代器与传统迭代器的不同之处在于，它不是以形式返回普通对象{value, done}，而是返回履行的承诺{value, done}。异步迭代定义了一个返回异步迭代器的Symbol.asyncIterator方法（而不是Symbol.iterator）。 一个例子让这个更清楚： 1234567891011121314151617181920212223242526272829303132333435const collection = &#123; a: 10, b: 20, c: 30, [Symbol.asyncIterator]() &#123; const values = Object.keys(this); let i = 0; return &#123; next: () =&gt; &#123; return Promise.resolve(&#123; value: this[values[i++]], done: i &gt; values.length &#125;); &#125; &#125;; &#125;&#125;;const iterator = collection[Symbol.asyncIterator](); console.log(iterator.next().then(result =&gt; &#123; console.log(result); // → &#123;value: 10, done: false&#125;&#125;));console.log(iterator.next().then(result =&gt; &#123; console.log(result); // → &#123;value: 20, done: false&#125; &#125;));console.log(iterator.next().then(result =&gt; &#123; console.log(result); // → &#123;value: 30, done: false&#125; &#125;));console.log(iterator.next().then(result =&gt; &#123; console.log(result); // → &#123;value: undefined, done: true&#125; &#125;)); 请注意，不可使用promises的迭代器来实现相同的结果。虽然普通的同步迭代器可以异步确定值，但它仍然需要同步确定done的状态。 同样，您可以使用生成器函数简化过程，如下所示： 12345678910111213141516171819202122232425262728const collection = &#123; a: 10, b: 20, c: 30, [Symbol.asyncIterator]: async function * () &#123; for (let key in this) &#123; yield this[key]; &#125; &#125;&#125;;const iterator = collection[Symbol.asyncIterator](); console.log(iterator.next().then(result =&gt; &#123; console.log(result); // → &#123;value: 10, done: false&#125;&#125;));console.log(iterator.next().then(result =&gt; &#123; console.log(result); // → &#123;value: 20, done: false&#125; &#125;));console.log(iterator.next().then(result =&gt; &#123; console.log(result); // → &#123;value: 30, done: false&#125; &#125;));console.log(iterator.next().then(result =&gt; &#123; console.log(result); // → &#123;value: undefined, done: true&#125; &#125;)); 通常，生成器函数返回带有next()方法的生成器对象。当调用next()时，它返回一个{value，done}，其value属性保存了yield值。异步生成器执行相同的操作，除了它返回一个履行{value，done}的promise。 迭代可迭代对象的一种简单方法是使用for...of语句，但是for...of不能与async iterables一起使用，因为value和done不是同步确定的。因此，ES2018提供了for...await...of。我们来看一个例子： 123456789101112131415161718192021const collection = &#123; a: 10, b: 20, c: 30, [Symbol.asyncIterator]: async function * () &#123; for (let key in this) &#123; yield this[key]; &#125; &#125;&#125;;(async function () &#123; for await (const x of collection) &#123; console.log(x); &#125;&#125;)();// logs:// → 10// → 20// → 30 在此代码中，for...await...of语句隐式调用Symbol.asyncIterator集合对象上的方法以获取异步迭代器。每次循环时，都会调用迭代器的next()方法，它返回一个promise。一旦解析了promise，就会将结果对象的value属性读取到x变量中。循环继续，直到返回的对象的done属性值为true。 请记住，该for...await...of语句仅在异步生成器和异步函数中有效。违反此规则会导致一个SyntaxError报错。 next()方法可能会返回拒绝的promise。要优雅地处理被拒绝的promise，您可以将for...await...of语句包装在语句中try...catch，如下所示： 1234567891011121314151617181920const collection = &#123; [Symbol.asyncIterator]() &#123; return &#123; next: () =&gt; &#123; return Promise.reject(new Error('Something went wrong.')) &#125; &#125;; &#125;&#125;;(async function() &#123; try &#123; for await (const value of collection) &#123;&#125; &#125; catch (error) &#123; console.log('Caught: ' + error.message); &#125;&#125;)();// logs:// → Caught: Something went wrong. Support for Asynchronous Iterators Chrome Firefox Safari Edge 63 57 12 No Chrome Android Firefox Android iOS Safari Edge Mobile Samsung Internet Android Webview 63 57 12 No 8.2 63 Node.js 8.0.0（运行时需要加-harmony） 8.3.0（完全支持） Promise.prototype.finallyES2018的另一个令人兴奋的补充是finally()方法。一些JavaScript库之前已经实现了类似的方法，这在许多情况下证明是有用的。这鼓励了Ecma技术委员会正式添加finally()到规范中。使用这个方法，程序员将能不管promise的结果如何，都能执行一个代码块。我们来看一个简单的例子： 12345678910fetch('https://www.google.com') .then((response) =&gt; &#123; console.log(response.status); &#125;) .catch((error) =&gt; &#123; console.log(error); &#125;) .finally(() =&gt; &#123; document.querySelector('#spinner').style.display = 'none'; &#125;); finally()无论操作是否成功，当您需要在操作完成后进行一些清理时，该方法会派上用场。在此代码中，该finally()方法只是在获取和处理数据后隐藏加载微调器。代码不是在then()和catch()方法中复制最终逻辑，而是在promise被fulfilled或rejected后注册要执行的函数。 你可以使用promise.then(func，func)而不是promise.finally(func)来实现相同的结果，但你必须在fulfillment处理程序和rejection处理程序中重复相同的代码，或者为它声明一个变量： 123456789101112fetch('https://www.google.com') .then((response) =&gt; &#123; console.log(response.status); &#125;) .catch((error) =&gt; &#123; console.log(error); &#125;) .then(final, final);function final() &#123; document.querySelector('#spinner').style.display = 'none';&#125; 和then()和catch()一样，finally()方法总是返回一个promise，因此可以链接更多的方法。通常，您希望使用finally()作为最后一个链，但在某些情况下，例如在发出HTTP请求时，最好链接另一个catch()以处理finally()中可能发生的错误。 Support for Promise.prototype.finally Chrome Firefox Safari Edge 63 58 11.1 18 Chrome Android Firefox Android iOS Safari Edge Mobile Samsung Internet Android Webview 63 58 11.1 No 8.2 63 Node.js 10.0.0（完全支持） 新的RegExp功能ES2018为该RegExp对象增加了四个新功能，进一步提高了JavaScript的字符串处理能力。这些功能如下： S（DOTALL）标志 Named Capture Groups(命名捕获组) Lookbehind Assertions(后向断言) Unicode Property Escapes(Unicode属性转义) S（DOTALL）标志点（.）是正则表达式模式中的特殊字符，它匹配除换行符之外的任何字符，例如换行符（\\n）或回车符（\\r）。匹配所有字符（包括换行符）的解决方法是使用具有两个相反短字的字符类，例如[\\d\\D]。此字符类告诉正则表达式引擎找到一个数字（\\d）或非数字（\\D）的字符。因此，它匹配任何字符： 1console.log(/one[\\d\\D]two/.test('one\\ntwo')); // → true ES2018引入了一种模式，其中点可用于实现相同的结果。可以使用s标志在每个正则表达式的基础上激活此模式： 12console.log(/one.two/.test('one\\ntwo')); // → falseconsole.log(/one.two/s.test('one\\ntwo')); // → true 使用标志来选择新行为的好处是向后兼容性。因此，使用点字符的现有正则表达式模式不受影响。 Named Capture Groups(命名捕获组)在一些正则表达式模式中，使用数字来引用捕获组可能会令人困惑。例如，使用/(\\d{4})-(\\d{2})-(\\d{2})/与日期匹配的正则表达式。由于美式英语中的日期符号与英式英语不同，因此很难知道哪个组指的是哪一天，哪个组指的是月份： 1234567const re = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;const match= re.exec('2019-01-10');console.log(match[0]); // → 2019-01-10console.log(match[1]); // → 2019console.log(match[2]); // → 01console.log(match[3]); // → 10 ES2018引入了使用(?&lt;name&gt;...)语法的命名捕获组。因此，匹配日期的模式可以用不那么模糊的方式编写： 1234567const re = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/;const match = re.exec('2019-01-10');console.log(match.groups); // → &#123;year: \"2019\", month: \"01\", day: \"10\"&#125;console.log(match.groups.year); // → 2019console.log(match.groups.month); // → 01console.log(match.groups.day); // → 10 您可以使用\\k&lt;name&gt;语法在模式中稍后调用命名的捕获组。例如，要在句子中查找连续的重复单词，您可以使用/\\b(?&lt;dup&gt;\\w+)\\s+\\k&lt;dup&gt;\\b/： 12345const re = /\\b(?&lt;dup&gt;\\w+)\\s+\\k&lt;dup&gt;\\b/;const match = re.exec('Get that that cat off the table!'); console.log(match.index); // → 4console.log(match[0]); // → that that 要将命名的捕获组插入到方法的替换字符串中replace()，您需要使用$&lt;name&gt;构造。例如： 1234567const str = 'red &amp; blue';console.log(str.replace(/(red) &amp; (blue)/, '$2 &amp; $1')); // → blue &amp; redconsole.log(str.replace(/(?&lt;red&gt;red) &amp; (?&lt;blue&gt;blue)/, '$&lt;blue&gt; &amp; $&lt;red&gt;')); // → blue &amp; red Lookbehind Assertions(后向断言)ES2018为JavaScript带来了后向性断言，这些断言已经在其他正则表达式实现中可用多年。以前，JavaScript只支持超前断言。后向断言用表示(?&lt;=...)，并使您能够匹配基于模式之前的子字符串的模式。例如，如果要在不捕获货币符号的情况下以美元，英镑或欧元匹配产品的价格，则可以使用/(?&lt;=\\$|£|€)\\d+(\\.\\d*)?/： 12345678910const re = /(?&lt;=\\$|£|€)\\d+(\\.\\d*)?/;console.log(re.exec('199')); // → nullconsole.log(re.exec('$199')); // → [\"199\", undefined, index: 1, input: \"$199\", groups: undefined]console.log(re.exec('€50')); // → [\"50\", undefined, index: 1, input: \"€50\", groups: undefined] 还有一个lookbehind的否定版本，用(?&lt;!...)，只有当模式前面没有lookbehind中的模式时，负lookbehind才允许您匹配模式。例如，模式/(?&lt;!un)available/匹配没有“un”前缀的可用词 这段翻译的不好，放上原文 There is also a negative version of lookbehind, which is denoted by (?&lt;!...). A negative lookbehind allows you to match a pattern only if it is not preceded by the pattern within the lookbehind. For example, the pattern /(?&lt;!un)available/ matches the word available if it does not have a “un” prefix: Unicode Property Escapes(Unicode属性转义)ES2018提供了一种称为Unicode属性转义的新类型转义序列，它在正则表达式中提供对完整Unicode的支持。假设您要在字符串中匹配Unicode字符㉛。虽然㉛被认为是一个数字，但是你不能将它与\\d速记字符类匹配，因为它只支持ASCII [0-9]字符。另一方面，Unicode属性转义可用于匹配Unicode中的任何十进制数： 1234const str = '㉛';console.log(/\\d/u.test(str)); // → falseconsole.log(/\\p&#123;Number&#125;/u.test(str)); // → true 同样，如果要匹配任何Unicode字母字符，你可以使用\\p{Alphabetic}： 123456const str = 'ض';console.log(/\\p&#123;Alphabetic&#125;/u.test(str)); // → true// the \\w shorthand cannot match ض console.log(/\\w/u.test(str)); // → false 还有一个否定版本\\p{...}，表示为\\P{...}： 12345console.log(/\\P&#123;Number&#125;/u.test('㉛')); // → falseconsole.log(/\\P&#123;Number&#125;/u.test('ض')); // → trueconsole.log(/\\P&#123;Alphabetic&#125;/u.test('㉛')); // → trueconsole.log(/\\P&#123;Alphabetic&#125;/u.test('ض')); // → false 除了字母和数字之外，还有几个属性可以在Unicode属性转义中使用。您可以在当前规范提案中找到支持的Unicode属性列表。 Support for New RegExp * Chrome Firefox Safari Edge S（DOTALL）标志 62 No 11.1 No 命名捕获组 64 No 11.1 No 后向断言 62 No No No Unicode属性转义 64 No 11.1 No * Chrome Android Firefox Android iOS Safari Edge Mobile Samsung Internet Android Webview S（DOTALL）标志 62 No 11.3 No 8.2 62 命名捕获组 64 No 11.3 No No 64 后向断言 62 No No No 8.2 62 Unicode属性转义 64 No 11.3 No No 64 Node.js 8.3.0 (运行时需要加-harmony) 8.10.0 (support for s (dotAll) flag and lookbehind assertions) 10.0.0 (完全支持) 模板字符串当模板字符串紧跟在表达式之后时，它被称为标记模板字符串。当您想要使用函数解析模板文字时，标记的模板会派上用场。请考虑以下示例： 1234567891011function fn(string, substitute) &#123; if(substitute === 'ES6') &#123; substitute = 'ES2015' &#125; return substitute + string[1];&#125;const version = 'ES6';const result = fn`$&#123;version&#125; was a major update`;console.log(result); // → ES2015 was a major update 在此代码中，调用标记表达式（它是常规函数）并传递模板文字。该函数只是修改字符串的动态部分并返回它。 在ES2018之前，标记的模板字符串具有与转义序列相关的语法限制。反斜杠后跟某些字符序列被视为特殊字符：\\x解释为十六进制转义符，\\u解释为unicode转义符，\\后跟一个数字解释为八进制转义符。其结果是，字符串，例如”C:\\xxx\\uuu“或者”\\ubuntu“被认为是由解释无效转义序列，并会抛出SyntaxError。 ES2018从标记模板中删除了这些限制，而不是抛出错误，表示无效的转义序列如下undefined 1234567function fn(string, substitute) &#123; console.log(substitute); // → escape sequences: console.log(string[1]); // → undefined&#125;const str = 'escape sequences:';const result = fn`$&#123;str&#125; \\ubuntu C:\\xxx\\uuu`; 请记住，在常规模板文字中使用非法转义序列仍会导致错误： 12const result = `\\ubuntu`;// → SyntaxError: Invalid Unicode escape sequence Support for Template Literal Revision Chrome Firefox Safari Edge 62 56 11 No Chrome Android Firefox Android iOS Safari Edge Mobile Samsung Internet Android Webview 62 56 11 No 8.2 62 Node.js 8.3.0 （运行时需要加-harmony） 8.10.0（完全支持） 总结我们已经仔细研究了ES2018中引入的几个关键特性，包括异步迭代，rest/spread属性Promise.prototype.finally()以及RegExp对象的添加。虽然其中一些浏览器供应商尚未完全实现其中一些功能，但由于像Babel这样的JavaScript转换器，它们今天仍然可以使用。 ECMAScript正在迅速发展，并且每隔一段时间就会引入新功能，因此请查看已完成提案的列表，了解新功能的全部内容。 第一次翻译文章，能力有限，水平一般，翻译不妥之处，还望指正。感谢。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://timbok.github.io/categories/JavaScript/"}],"tags":[]},{"title":"react打怪笔记","slug":"react打怪笔记","date":"2018-12-19T08:39:01.000Z","updated":"2020-04-15T12:16:58.181Z","comments":true,"path":"2018/12/19/react打怪笔记/","link":"","permalink":"https://timbok.github.io/2018/12/19/react打怪笔记/","excerpt":"","text":"介绍本文为学习react中的记录。 Tips: 当组件的props或state有变化，执行render函数。 无论是使用函数或是类来声明一个组件，它决不能修改它自己的props React 可以将多个setState() 调用合并成一个调用来提高性能。 无状态函数式组件 (stateless functional component)React v16.7.0-alpha(内测) 将引入 Hooks, 这将意味着函数式组件将拥有类似类组件的特性。 无生命周期方法函数式组件，有时也被称为无状态组件，没有任何生命周期方法，意味着每次上层组件树状态发生变更时它们都会重新渲染，这就是因为缺少 shouldComponentUpdate 方法导致的。这也同样意味着您不能定义某些基于组件挂载和卸载的行为。 没有 this 和 ref更有趣的是您在函数式组件中既不能使用 this关键字或访问到 ref。对于习惯了严格意义上的类或面向对象风格的人来说，这很让他们惊讶。这也是使用函数最大的争论点。另一个有趣的事实就是您仍然可以访问到 context，如果您将 context 定义为函数的一个 props。 避免常见陷阱在编写无状态函数式组件时，您需要避免某些特定的模式。避免在函数式组件中定义函数，这是因为每一次函数式组件被调用的时候，一个新的函数都会被创建。 123456const Functional = (&#123;...&#125;) =&gt; &#123; const handleSomething = e =&gt; path(['event', 'target'], e) return ( // ... )&#125; 这个问题很容易解决，您可以将这个函数作为 props 传递进去，或者将它定义在组件外面。 12const handleSomething = e =&gt; path(['event', 'target'], e)const Functional = (&#123;...&#125;) =&gt; // ... 生命周期概况 生命周期演示 1.初始化在组件初始化阶段会执行 constructor static getDerivedStateFromProps() componentWillMount() / UNSAFE_componentWillMount() render() componentDidMount() 2.更新阶段props或state的改变可能会引起组件的更新，组件重新渲染的过程中会调用以下方法： componentWillReceiveProps() / UNSAFE_componentWillReceiveProps() static getDerivedStateFromProps() shouldComponentUpdate() componentWillUpdate() / UNSAFE_componentWillUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate() 3.卸载阶段 componentWillUnmount() 4.错误处理 componentDidCatch() 详解1.constructor(props)react组件的构造函数在挂载之前被调用。在实现React.Component构造函数时，需要先在添加其他内容前，调用super(props)，用来将父组件传来的props绑定到这个类中，使用this.props将会得到。 官方建议不要在constructor引入任何具有副作用和订阅功能的代码，这些应当在componentDidMount()中写入。 constructor中应当做些初始化的动作，如：初始化state，将事件处理函数绑定到类实例上，但也不要使用setState()。如果没有必要初始化state或绑定方法，则不需要构造constructor，或者把这个组件换成纯函数写法。 当然也可以利用props初始化state，在之后修改state不会对props造成任何修改，但仍然建议大家提升状态到父组件中，或使用redux统一进行状态管理。 123456constructor(props) &#123; super(props); this.state = &#123; color: props.initialColor &#125;;&#125; 2.static getDerivedStateFromProps(nextProps, prevState)getDerivedStateFromProps在组件实例化后，和接受新的props后被调用。他返回一个对象来更新状态，或者返回null表示新的props不需要任何state的更新。 如果是由于父组件的props更改，所带来的重新渲染，也会触发此方法。 调用steState()不会触发getDerivedStateFromProps()。 3. componentWillMount() / UNSAFE_componentWillMount()componentWillMount()将在react未来版本中被弃用。UNSAFE_componentWillMount()在组件挂载前被调用，在这个方法中调用setState()不会起作用，是由于他在render()前被调用。 为了避免副作用和其他的订阅，官方都建议使用componentDidMount()代替。这个方法是用于在服务器渲染上的唯一方法。 4.render()render()方法是必需的。当他被调用时，他将计算this.props和this.state，并返回以下一种类型： React元素。通过jsx创建，既可以是dom元素，也可以是用户自定义的组件。 字符串或数字。他们将会以文本节点形式渲染到dom中。 Portals。react 16版本中提出的新的解决方案，可以使组件脱离父组件层级直接挂载在DOM树的任何位置。 null，什么也不渲染 布尔值。也是什么都不渲染，通常后跟组件进行判断。 当返回null,false,ReactDOM.findDOMNode(this)将会返回null，什么都不会渲染。 render()方法必须是一个纯函数，他不应该改变state，也不能直接和浏览器进行交互，应该将事件放在其他生命周期函数中。如果shouldComponentUpdate()返回false，render()不会被调用。 Fragments你也可以在render()中使用数组，如：(不要忘记给每个数组元素添加key，防止出现警告)1234567render() &#123; return [ &lt;li key=\"A\"&gt;First item&lt;/li&gt;, &lt;li key=\"B\"&gt;Second item&lt;/li&gt;, &lt;li key=\"C\"&gt;Third item&lt;/li&gt;, ];&#125; 换一种写法，可以不写key（v16++）123456789render() &#123; return ( &lt;React.Fragment&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;/React.Fragment&gt; );&#125; 官方示例: 1234567891011121314151617function Clock(props) &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; );&#125;function tick() &#123; ReactDOM.render( &lt;Clock date=&#123;new Date()&#125; /&gt;, document.getElementById('root') );&#125;setInterval(tick, 1000); 5.componentWillReceiveProps()/UNSAFE_componentWillReceiveProps(nextProps)官方建议使用getDerivedStateFromProps函数代替componentWillReceiveProps()。当组件挂载后，接收到新的props后会被调用。如果需要更新state来响应props的更改，则可以进行this.props和nextProps的比较，并在此方法中使用this.setState()。 如果父组件会让这个组件重新渲染，即使props没有改变，也会调用这个方法。 react不会在组件初始化props时调用这个方法。调用this.setState也不会触发。 6.shouldComponentUpdate(nextProps, nextState)调用shouldComponentUpdate使react知道，组件的输出是否受state和props的影响。默认每个状态的更改都会重新渲染，大多数情况下应该保持这个默认行为。 在渲染新的props或state前，shouldComponentUpdate会被调用。默认为true。这个方法不会在初始化时被调用，也不会在forceUpdate()时被调用。返回false不会阻止子组件在state更改时重新渲染。 如果shouldComponentUpdate()返回false，componentwillupdate,render和componentDidUpdate不会被调用。 在未来版本，shouldComponentUpdate()将会作为一个提示而不是严格的指令，返回false仍然可能导致组件的重新渲染。官方并不建议在shouldComponentUpdate()中进行深度查询或使用JSON.stringify()，他效率非常低，并且损伤性能。 7.UNSAFE_componentWillUpdate(nextProps, nextState)在渲染新的state或props时，UNSAFE_componentWillUpdate会被调用，将此作为在更新发生之前进行准备的机会。这个方法不会在初始化时被调用。 不能在这里使用this.setState()，也不能做会触发视图更新的操作。如果需要更新state或props，调用getDerivedStateFromProps。 8.getSnapshotBeforeUpdate()在react render()后的输出被渲染到DOM之前被调用。它使您的组件能够在它们被潜在更改之前捕获当前值（如滚动位置）。这个生命周期返回的任何值都将作为参数传递给componentDidUpdate()。 9.componentDidUpdate(prevProps, prevState, snapshot)在更新发生后立即调用componentDidUpdate()。此方法不用于初始渲染。当组件更新时，将此作为一个机会来操作DOM。只要您将当前的props与以前的props进行比较（例如，如果props没有改变，则可能不需要网络请求），这也是做网络请求的好地方。 如果组件实现getSnapshotBeforeUpdate()生命周期，则它返回的值将作为第三个“快照”参数传递给componentDidUpdate()。否则，这个参数是undefined。 10.componentWillUnmount()在组件被卸载并销毁之前立即被调用。在此方法中执行任何必要的清理，例如使定时器无效，取消网络请求或清理在componentDidMount（）中创建的任何监听。 11.componentDidCatch(error, info)错误边界是React组件，可以在其子组件树中的任何位置捕获JavaScript错误，记录这些错误并显示回退UI，而不是崩溃的组件树。错误边界在渲染期间，生命周期方法以及整个树下的构造函数中捕获错误。 如果类组件定义了此生命周期方法，则它将成为错误边界。在它中调用setState()可以让你在下面的树中捕获未处理的JavaScript错误，并显示一个后备UI。只能使用错误边界从意外异常中恢复;不要试图将它们用于控制流程。详细 错误边界只会捕获树中下面组件中的错误。错误边界本身不能捕获错误。 为什么虚拟dom会提高性能?虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能。 具体实现步骤如下： 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了。 参考链接 参考文档 React v16.3.0: New lifecycles and context API React.Component mytac","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://timbok.github.io/categories/JavaScript/"}],"tags":[]},{"title":"给Hexo搭建的博客绑定域名","slug":"Hexo域名","date":"2018-12-02T07:25:54.000Z","updated":"2020-04-15T12:16:58.176Z","comments":true,"path":"2018/12/02/Hexo域名/","link":"","permalink":"https://timbok.github.io/2018/12/02/Hexo域名/","excerpt":"","text":"前言前几天利用闲置时间，利用hexo在GitHub上搭建了一个静态博客，那么既然是个人博客，当然要上自己的域名了。 step-1首先你得你得搭建 XXX.github.io 这样的博客，[hexo教程]。 step-2你的博客可以访问后，去阿里云、腾讯云等网站去注册个域名。 step-3获取博客的ip地址 Tips: 这一步主要为了解析域名，不获取IP的话，step4解析A类型就行 第一： clone 你创建的 仓库 xxx.github.io 第二： git的输入 ping www.xxx.github.io 得到IP 如下图： step-4等域名审核完后，和我相关的就来了。以下用阿里云注册的域名为例。进入阿里云的管理控制台-域名与网站-云解析DNS，进入域名的解析设置，点击新手指导，将得到的 IP 地址填到记录值一栏，点击确定就 OK 了。填完以后的解析列表会出现： 记录值就是自己 github 的二级域名的 IP地址。 Tips: 一般解析都需要点时间，等个20分钟左右就好了 step-5在hexo项目下 source 文件下创建CNAME 文件（没有后缀名的），在里面写上购买的域名，例如： step-6最后到你 xxx.github.io 的Settings里，填上你的域名 这样新域名就ok啦，可以访问了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://timbok.github.io/categories/Hexo/"}],"tags":[]},{"title":"Git中遇到的大大小小的坑","slug":"Git","date":"2018-11-29T12:41:49.000Z","updated":"2020-04-15T12:16:58.175Z","comments":true,"path":"2018/11/29/Git/","link":"","permalink":"https://timbok.github.io/2018/11/29/Git/","excerpt":"","text":"目的：记录自己平时在项目中遇到的坑 Tips 不要在dev上操作。 更新git: git update- 暂存修改的文件12git add [fileName] ——暂存某个文件 git add . ——暂存所有修改的文件 撤销本地修改文件12git checkout [fileName] ——撤销某个文件 git checkout . ——撤销所有修改的文件 提交暂存区文件 fix：修复bug update：更新文件 add：新增文件 modify：重命名 delete：删除文件 git commit -m &quot;你的提交备注&quot; 不想commit，那就储藏12345git stash ——储藏 git stash pop/apply ——弹出储藏 git stash save 'message' ——储藏是加message git stash drop stash@&#123;$num&#125; ——丢弃stash@&#123;$num&#125;存储，从列表中删除这个存储 git stash clear --删除所有缓存的stash 将本地仓库的代码推到远程分支1git push [远程分支名] 切换分支1&gt; git checkout [你要切换的分支名] 注释：切换分支之前，一定要将修改的文件提交或者放进储藏区 拉取远程分支代码12git pull orgin [分支名] git pull ——拉取当前分支的代码 合并分支1git merge [你要合并的分支名] 查看本地分支1git branch 查看远程分支1git branch -a 修改分支名称git branch -m ordBranch newBranch 删除本地分支git branch -d/-D [你要删除的分支] 删除远程分支git push origin --delete [你要删除掉的分支] 等同于 git push origin :[你要删除掉的分支] 本地分支推到远程并关联git push --set-upstream origin _branch 查看提交记录12git log git log -5 查看五条记录 查看被删除的提交记录git reflog 回滚代码12git reset [commitId] 回滚代码但修改的代码还在git reset --hard [commitId] 回滚代码且修改的代码也没了 推送代码git push orgin [当前分支]:devlop 连接远程仓库123git remote add origin 仓库地址仓库地址：https://git.coding.net/xxxxxxxxxxxxx/my-project.git git push -u orgin master 删除远程仓库git remote remove origin 远程仓库删除，本地分支没有删除123git remote show origin 查看远程分支的信息git remote prune origin --dry-run 查看可清理的远程分支git remote prune origin 删除可清理的远程分支 记住远程git仓库账号密码永久记录 git config --global credential.helper store 自定义记住时间 - 1小时 git config credential.helper ‘cache –timeout=3600’ 重置git密码git config --unset credential.helper 修改远程仓库名git remote set-url origin [] 直接指定clone某个分支：git clone -b &lt;branch name&gt; [remote repository address]","categories":[{"name":"Git","slug":"Git","permalink":"https://timbok.github.io/categories/Git/"}],"tags":[]},{"title":"三分钟教你同步 visual studio code 设置","slug":"vscode","date":"2018-11-28T11:57:11.000Z","updated":"2020-04-15T12:16:58.182Z","comments":true,"path":"2018/11/28/vscode/","link":"","permalink":"https://timbok.github.io/2018/11/28/vscode/","excerpt":"","text":"简介Visual Studio Code(以下简称vsCode)现在已经渐渐成为前端开发的主力工具，谁让它这么轻便，功能又这么轻便呢。用vscode Coding的小伙伴们也一定会装很多插件吧。但是当你准备更换电脑的时候，是不是为迁移插件和设置而烦恼？我曾经换电脑的时候，把vsCode上自己心爱的插件一个个记下，然后去新电脑上重装，太蠢了。今天我就把vsCode同步设置和插件的方法告诉大家。 准备工作 下载Settings Sync插件 GitHub账号 1.安装Settings Sync Setting Sync 快捷键： 1) 上传： Shift + Alt + U (Sync: Update / Upload Settings) 2) 下载： Shift + Alt + D (Sync: Download Settings) 如果快捷键有冲突，可Ctrl + K + S快捷键设置配置其它快捷键 或 Ctrl + P / F1 在命令窗口输入 &gt;sync 即会出现相应命令供选择 2.打开GitHub 这样你就得到一个token，最好找个地方记下来。因为它就是同步设置的关键。 3.将token配置到vsCode(Sync: Update / Uplaod Settings) Shift + Alt + U 在弹窗里输入你的token， 回车后会生成syncSummary.txt文件 syncSummary.txt文件会存储VSCode的设置及所安装的插件列表 如果你使用的是新版本的vsCode 打开设置，在搜索框中输入sync，就可以看到自己的token了 4.设置同步下载设置(Sync: Download Settings) Shift + Alt + D 在弹窗里输入你的gist值，稍后片刻便可同步成功 5.如果要重置同步设置，变更其它tokenCtrl+P / F1 弹出输入&gt;sync,即可重新配置你的其它token来同步 6.Tips上传同步设置的时候，vsCode底下可以看到操作信息 Setting Sync 可同步包含的所有扩展和完整的用户文件夹 1) 设置文件 2) 快捷键设置文件 3) Launch File 4) Snippets Folder 5) VSCode 扩展设置 6) 工作空间 博客同步更新 参考文章 Settings Sync更新说明","categories":[{"name":"工具资源","slug":"工具资源","permalink":"https://timbok.github.io/categories/工具资源/"}],"tags":[]}]}